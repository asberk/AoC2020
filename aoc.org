* Advent of Code 2020


  
** Goals

 - I would like to write the whole thing (or as much as possible) in Lisp. Where
   that fails, I may try to use C.

** Resources

   - see this [[https://stackoverflow.com/q/25652002/1456421][this SO post]] for reading in data.
   - See [[https://lispcookbook.github.io/cl-cookbook/iteration.html][lisp cookbook]] for examples of how to use ~LOOP~

** Utilities
   :PROPERTIES:
   :ID:       0B64C670-1156-4BFB-838B-B85F9F9F234C
   :END:


   #+begin_src lisp :exports both :results output :tangle my-utils.lisp 
     (defparameter *aoc-dir* "code/aoc20/inputs/")

     (defun get-puzzle-input-fpath (fname)
       "Return ~/code/aoc20/inputs/FNAME"
       (concatenate 'string (namestring (user-homedir-pathname)) *aoc-dir* fname))

     (defun form-length (quoted-form)
       (length (princ-to-string quoted-form)))

     (defun longest-form-length (&rest quoted-forms)
       (loop for f in quoted-forms maximizing (form-length f)))

     (defun verbosify1 (form tablength result)
       "Tries to keep everything on one line."
       (format t "~a~v,0t : -> ~a~%" form tablength result))

     (defun verbosify2 (form result)
       "Two-line formatting"
       (format t "~a~%~2t : -> ~a~%" form result))

     (defmacro verbose1 (&body forms)
       (let ((len-name (gensym)))
         `(let ((,len-name (apply #'longest-form-length ',forms)))
            (progn
              ,@(loop for form in forms
                   collect `(verbosify1 ',form ,len-name ,form))))))

     (defmacro verbose2 (&body forms)
       `(progn
          ,@(loop for form in forms
               collect `(verbosify2 ',form ,form))))

     (defun read-file (filename &optional (reader #'read-line))
       "Read a file from FILENAME and return it as a list of lines."
       (with-open-file (data (get-puzzle-input-fpath filename))
         (loop for line = (funcall reader data nil)
            while line collect line)))

   #+end_src

   #+RESULTS:
  
** Day 1
   :PROPERTIES:
   :ID:       F7024D2A-1593-402A-B1D1-7EF42D3C984D
   :END:


    #+begin_src lisp :exports both :results output :tangle day01.lisp :shebang "#!/usr/bin/env sbcl --script"
      (load "my-utils.lisp")

      (defun day1-part1 ()
        ""
        (let ((d1-input (read-file "d1.txt" #'read)))
          (loop named outer-loop
             for a in d1-input
             do (loop for b in d1-input
                   when (= (+ a b) 2020)
                   do (return-from outer-loop (* a b))))))


      (defun day1-part1-method2 ()
        (block loops
          (let ((d1-input (read-file "d1.txt" #'read)))
            (dolist (a d1-input)
              (dolist (b d1-input)
                (when (= (+ a b) 2020)
                  (return-from loops (* a b))))))))

      (defun day1-part2 ()
        (block loops
          (let ((d1-input (read-file "d1.txt" #'read)))
            (dolist (a d1-input)
              (dolist (b d1-input)
                (dolist (c d1-input)
                  (when (= (+ a b c) 2020)
                    (return-from loops (* a b c)))))))))

      (verbose1
        (day1-part1)
        (day1-part1-method2)
        (day1-part2))
    #+end_src

    #+RESULTS:
    : (DAY1-PART1)         : -> 870331
    : (DAY1-PART1-METHOD2) : -> 870331
    : (DAY1-PART2)         : -> 283025088
    
** Day 2
   :PROPERTIES:
   :ID:       FCD2425A-5628-44EB-8AD9-22E127A8A051
   :END:

    #+begin_src lisp :exports both :results output :tangle day02.lisp :shebang "#!/usr/bin/env sbcl --script"
      (load "my-utils.lisp")

      (defparameter *day2* (read-file "d2.txt"))

      (defun parse-toboggan-password (line)
        (let ((hyphen-loc (search "-" line))
              (colon-loc (search ": " line)))
          (list
           (parse-integer (subseq line 0 hyphen-loc))
           (read-from-string (subseq line (1+ hyphen-loc)))
           (subseq line (1- colon-loc) colon-loc)
           (subseq line (+ 2 colon-loc)))))

      (defun count-char-occurence (password letter)
        (count-if #'(lambda (c) (string= c letter)) password))

      (defun letter-count-in-bounds-p (lower upper letter-count)
        (<= lower letter-count upper))

      (defun p1-valid-password-p (line)
        (let* ((parsed (parse-toboggan-password line))
               (lower (first parsed))
               (upper (second parsed))
               (letter (third parsed))
               (password (fourth parsed)))
          (letter-count-in-bounds-p
           lower upper (count-char-occurence
                        password letter))))

      (defun extract-letter-from-position (string pos)
        "Note that this is one-indexed as the challenge demands!"
        (subseq string (1- pos) pos))

      (defun xor (a b)
        (and (or a b) (not (and a b))))


      (defun p2-valid-password-p (line)
        (let* ((parsed (parse-toboggan-password line))
               (pos1 (first parsed))
               (pos2 (second parsed))
               (letter (third parsed))
               (password (fourth parsed))
               (letter1 (extract-letter-from-position password pos1))
               (letter2 (extract-letter-from-position password pos2)))
          (xor (string= letter1 letter) (string= letter2 letter))))

      (defun day2-part1 ()
        (count-if #'p1-valid-password-p *day2*))

      (defun day2-part2 ()
        (count-if #'p2-valid-password-p *day2*))

      (verbose1
        (day2-part1)
        (day2-part2))
    #+end_src

    #+RESULTS:
    : (DAY2-PART1) : -> 418
    : (DAY2-PART2) : -> 616

    
** Day 3
   :PROPERTIES:
   :ID:       B4D0AF4C-D061-4E67-BDBA-D3A11E4A62E1
   :END:

   #+begin_src lisp :exports both :results output :tangle day03.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")

     (defun get-char-at-pos (line pos)
       (subseq line pos (1+ pos)))

     (defun tree-p (line pos)
       (string= "#" (get-char-at-pos line pos)))

     (defun build-col-positions (nrows ncols slope)
       "Builds column positions for ski slope. SLOPE should be a cons cell
        corresponding with (right . down)."
       (loop for i from 0 to (ceiling (/ (1- nrows) (cdr slope)))
          collect (mod (* i (car slope)) ncols)))

     (defun row-subset (seq every-other)
       (cond ((< every-other 1) nil)
             ((= every-other 1) seq)
             (t (loop for x in seq
                   for i from 0
                   if (= (mod i every-other) 0)
                   collect x))))

     (defun find-num-trees (data slope)
       "Find the number of trees you'd run into. SLOPE is a cons cell with
        entries (RIGHT . DOWN)."
       (let* ((nr (length data))        ; nrows
              (nc (length (car data)))) ; ncols
         (count t (mapcar #'tree-p (row-subset data (cdr slope))
                          (build-col-positions nr nc slope)))))

     (defun day3-part1 ()
       (find-num-trees (read-file "d3.txt") (cons 3 1)))

     (defun day3-part2 ()
       (let ((day3 (read-file "d3.txt"))
             (slopes (list (cons 1 1) (cons 3 1) (cons 5 1) (cons 7 1) (cons 1 2))))
         (apply #'* (loop for slope in slopes collect (find-num-trees day3 slope)))))

     (verbose1
       (day3-part1)
       (day3-part2))
   #+end_src

   #+RESULTS:
   : (DAY3-PART1) : -> 169
   : (DAY3-PART2) : -> 7560370818

** Day 4
   :PROPERTIES:
   :ID:       3AE5B0B0-212A-4A27-989C-A4416BA78EC9
   :END:

   #+begin_src lisp :exports both :results output :tangle day04.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")

     (defparameter
         ,*required-fields* (list "byr" "iyr" "eyr" "hgt" "hcl" "ecl" "pid")
       "Field names that must be contained in a passport.")

     (defun get-colon-positions (string &optional (start 0))
       "Recursively return a list of indices corresponding to the colons in STRING."
       (let ((start (position #\: string :start start)))
         (cond (start (apply #'list start (get-colon-positions string (1+ start))))
               (t nil))))

     (defun get-field (string colon-loc)
       "Return the passport field associated with a given COLON-LOC."
       (subseq string (- colon-loc 3) colon-loc))

     (defun concat-strings (list)
       "Join a list of strings into one, separated by spaces."
       (if (and (listp list) (every #'stringp list))
           (with-output-to-string (s)
             (format s "~{~a~^ ~}" list))))

     (defun get-fields-from-string (string)
       "Return a list of all found passport fields in STRING."
       (mapcar #'(lambda (colon-loc) (get-field string colon-loc))
               (get-colon-positions string)))

     (defun get-fields-from-batch (batch)
       "Return a list of all found passport fields in BATCH. (helper function.)"
       (get-fields-from-string (concat-strings (reverse batch))))

     (defun on-fields (func fields)
       "Apply FUNC using FIELDS as the sequence against which to test membership."
       (funcall func #'(lambda (x) (member x fields :test #'string=)) *required-fields*))

     (defun num-required-fields (fields)
       "Count number of required fields found in FIELDS."
       (on-fields #'count-if fields))

     (defun contains-required-fields-p (fields)
       "Return T if all required passport fields were found in FIELDS; NIL otherwise."
       (on-fields #'every fields))

     (defun required-fields-p (line)
       "Return T if line contains all required passport fields (cf. *required-fields*)."
       (contains-required-fields-p (get-fields-from-string line)))

     ;; note: for some reason the last batch was not being processed by loop; we need
     ;; to collect it manually using this extra (slightly ugly) code.
     (defun traverse-collecting-field-names (data)
       (let* ((batch nil)
              (results
               (loop for line in data
                  if (string= line "")
                  collect (get-fields-from-batch batch)
                  and do (setf batch nil)
                  else do (push line batch))))
         (cond (batch (append results (list (get-fields-from-batch batch))))
               (t results))))

          ;;; code for part 2

     (defun lineify (data)
       "Transform DATA so that one passport entry corresponds with one string in the returned list."
       (let* ((batch nil)
              (results
               (loop for line in data
                  if (string= line "")
                  collect (concat-strings (reverse batch))
                  and do (setf batch nil)
                  else do (push line batch))))
         (cond (batch (append results (list (concat-strings (reverse batch)))))
               (t results))))

     (defun whitespacep (c)
       "Return T if C is a space or newline character."
       (or (char= c #\Space) (char= c #\Newline)))

     (defun colonp (c)
       "Return T if C is a colon character."
       (char= c #\:))

     (defun split-string (string &optional (predicate #'whitespacep))
       "Split STRING into multiple strings at the locations determined by
             PREDICATE. Default is to split at spaces/newlines."
       (let ((locs (loop for c across string for i from 0 if (funcall predicate c) collect i)))
         (setf locs (concatenate 'list (list 0) locs (list (length string))))
         (loop for i0 in locs
            for i1 in (cdr locs)
            collect (remove-if predicate (subseq string i0 i1)))))

     (defun parse-field-names-values (line)
       "Return a list of '(key value) lists for each key provided in LINE."
       (mapcar #'(lambda (x) (split-string x #'colonp)) (split-string line)))

     (defun string-number-in-bounds-p (string lower upper)
       "Determine if STRING represents a number that lies between lower and
             upper (inclusive)."
       (let ((n (parse-integer string :junk-allowed t)))
         (when n (<= lower n upper))))

     (defun valid-byr-p (byr)
       "Validate passport birth year IYR."
       (string-number-in-bounds-p byr 1920 2002))

     (defun valid-iyr-p (iyr)
       "Validate passport issue year IYR."
       (string-number-in-bounds-p iyr 2010 2020))

     (defun valid-eyr-p (eyr)
       "Validate passport expiration year EYR."
       (string-number-in-bounds-p eyr 2020 2030))

     (defun valid-hgt-p (hgt)
       "Validate height HEIGHT."
       (cond ((search "cm" hgt) (string-number-in-bounds-p hgt 150 193))
             ((search "in" hgt) (string-number-in-bounds-p hgt 59 76))
             (t nil)))

     (defun valid-hcl-p (hcl)
       "Validate hair colour HCL."
       (let ((hash-pos (position #\# hcl)) )
         (and hash-pos (= hash-pos 0) (= (length hcl) 7)
              (every
               #'(lambda (c) (position c "1234567890abcdef"))
               (subseq hcl 1)))))

     (defun valid-ecl-p (ecl)
       "Validate eye colour ECL."
       (not (null (member ecl (list "amb" "blu" "brn" "gry" "grn" "hzl" "oth") :test #'string=))))

     (defun valid-pid-p (pid)
       "Validate a passport id PID."
       (and (= (length pid) 9) (every #'(lambda (c) (position c "1234567890")) pid)))

     (defun valid-cid-p (cid) "Ignore CID entries and return T." t)

     (defun select-validator (field-name)
       "Select a validator to use according to FIELD-NAME."
       (cond ((string= field-name "byr") #'valid-byr-p)
             ((string= field-name "iyr") #'valid-iyr-p)
             ((string= field-name "eyr") #'valid-eyr-p)
             ((string= field-name "hgt") #'valid-hgt-p)
             ((string= field-name "hcl") #'valid-hcl-p)
             ((string= field-name "ecl") #'valid-ecl-p)
             ((string= field-name "pid") #'valid-pid-p)
             ((string= field-name "cid") #'valid-cid-p)
             (t (format t "Error: could not parse field name") nil)))

     (defun validate-field (field-kv)
       "Validate a passport key-value pair FIELD-KV, a two-element list."
       (funcall (select-validator (car field-kv)) (cadr field-kv)))

     (defun all-field-values-valid-p (line)
       "Validate all provided passport fields in LINE."
       (let ((parsed (parse-field-names-values line)))
         (every #'validate-field parsed)))

     (defun valid-passport-p (line)
       "Determine if LINE corresponds to a valid passport."
       (and (required-fields-p line) (all-field-values-valid-p line)))

     (defun day4-part1 ()
       (count 7 (mapcar #'num-required-fields
                        (traverse-collecting-field-names (read-file "d4.txt")))))

     (defun day4-part2 ()
       (count-if #'valid-passport-p (lineify (read-file "d4.txt"))))

     (verbose1 
       (day4-part1)
       (day4-part2))

   #+end_src

   #+RESULTS:
   : (DAY4-PART1) : -> 245
   : (DAY4-PART2) : -> 133

   
** Day 5
   :PROPERTIES:
   :ID:       D5D0FDF6-828E-400F-8DBF-FFCEF6F96A4E
   :END:

   #+begin_src lisp :exports both :results output :tangle day05.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")

     (defparameter *test-cases* (list "FBFBBFFRLR" "BFFFBBFRRR" "FFFBBBFRRR" "BBFFBBFRLL"))
     (defparameter *test-seat-ids* (list 357 567 119 820))


     (defun front-or-back-p (c)
       (or (char-equal c #\b) (char-equal c #\f)))

     (defun front-or-back (c)
       (cond ((char-equal c #\b) 1)
             ((char-equal c #\f) 0)
             (t nil)))

     (defun left-or-right (c)
       (cond ((char-equal c #\r) 1)
             ((char-equal c #\l) 0)
             (t nil)))

     (defun get-bit-from-character (c)
       (or (front-or-back c) (left-or-right c)))

     (defun get-bit-string (string)
       (loop for c across string collect (get-bit-from-character c)))

     (defun get-integer-from-bit-string (bit-string)
       (apply #'+ (loop for b in (reverse bit-string)
                     for j from 0
                     if (= b 1)
                     collect (expt 2 j))))

     (defun left-right-substr (string)
       (remove-if #'front-or-back-p string))

     (defun front-back-substr (string)
       (remove-if (complement #'front-or-back-p) string))

     (defun get-row-from-string (string)
       (get-integer-from-bit-string (get-bit-string (front-back-substr string))))

     (defun get-column-from-string (string)
       (get-integer-from-bit-string (get-bit-string (left-right-substr string))))

     (defun seat-id (string)
       (+ (* 8 (get-row-from-string string)) (get-column-from-string string)))

     (defun check-test-cases ()
       (when (notevery #'= (mapcar #'seat-id *test-cases*) *test-seat-ids*)
         (format t "Error: test cases did not pass")))

     (check-test-cases)

     (defun day5-part1 (&optional (data (read-file "d5.txt")))
       (loop for line in data maximizing (seat-id line)))

     (defun day5-part2 ()
       (let* ((day5 (read-file "d5.txt"))
              (parsed (mapcar #'seat-id day5))
              (max-id (apply #'max parsed))
              (found (loop for i from 1 to max-id
                        if (and (not (member i parsed))
                                (member (1- i) parsed)
                                (member (1+ i) parsed))
                        collect i)))
         (when (= (length found) 1)
           (car found))))

     (verbose1
       (day5-part1)
       (day5-part2))


   #+end_src

   #+RESULTS:
   : (DAY5-PART1) : -> 894
   : (DAY5-PART2) : -> 579

** Day 6
   :PROPERTIES:
   :ID:       3B91A8DA-B7D5-4114-8E27-B15B10E30F6B
   :END:


   #+begin_src lisp :exports both :results output :tangle day06.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")
     (load "~/.sbclrc")
     (ql:quickload "split-sequence")

     (defparameter *day6* (read-file "d6.txt") "Day 6 puzzle input")
     (defvar *lower*
       (loop with a = (char-code #\a)
             for i below 26
          collect (code-char (+ a i))))

     (defun split-input-by-groups (data)
       "Return a list of lists from DATA, assuming each entry is a string."
       (split-sequence:split-sequence
        0 data :key #'(lambda (x) (length x))))

     (defun output-formatter (string)
       (when string
         (sort (copy-seq (remove-duplicates string)) #'string<)))

     (defun parse-group-any (group)
       "Return GROUP as all found questions with duplicates removed."
       (output-formatter (apply #'concatenate 'string group)))

     (defun parse-group-every (group)
       "Return GROUP as all questions found for every GROUP member."
       (output-formatter
        (cond
          ((= (length group) 1) (car group))
          ((< (length group) 0) nil)
          (t (format nil "~{~A~}"
                     (loop for letter across (car group)
                        if (every #'(lambda (x) (position letter x))
                                  (cdr group))
                        collect letter))))))

     (defun num-questions (data group-parser)
       (apply #'+ (mapcar
                   (lambda (x) (length (funcall group-parser x)))
                   (split-input-by-groups data))))

     (defun day6-part1 ()
       (num-questions *day6* #'parse-group-any))

     (defun day6-part2 ()
       (num-questions *day6* #'parse-group-every))

     (verbose1
       (day6-part1)
       (day6-part2))


   #+end_src

   #+RESULTS:
   : (DAY6-PART1) : -> 6630
   : (DAY6-PART2) : -> 3437

** Day 7
   :PROPERTIES:
   :ID:       8E06349D-A4FD-4E83-B01C-9E8D66F7C4ED
   :END:


   #+begin_src lisp :exports both :results output :tangle day07.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")
     (load "~/.sbclrc")
     (ql:quickload "split-sequence")

     (defparameter *day7* (read-file "d7.txt"))

     ;;;; preprocessing

     (defun split-input-by-groups (data)
       "Return a list of lists from DATA, assuming each entry is a string."
       (split-sequence:split-sequence
        0 data :key #'(lambda (x) (length x))))

     (defun split-parent-child (line)
       (let* ((i0 (search " bags contain " line))
              (i1 (+ i0 14))
              (i2 (1- (length line))))
         (list (subseq line 0 i0) (subseq line i1 i2))))

     (defun no-other-bags-p (children-string)
       (search "no other bags" children-string))

     (defun remove-leading-space (string)
       "docstring"
       (let ((space-pos (position #\Space string)))
         (cond ((and space-pos (= space-pos 0)) (subseq string 1))
               (t string))))

     (defun split-children (children-string)
       "Split a string of all children into a list of each child item"
       (cond ((no-other-bags-p children-string) nil)
             (t (mapcar
                 #'remove-leading-space
                 (split-sequence:split-sequence #\, children-string)))))

     (defun parse-child (child-string)
       (let ((child (split-sequence:split-sequence #\Space child-string)))
         (cons
          (concatenate 'string (cadr child) " " (caddr child))
          (parse-integer (car child)))))

     (defun parse-line (line)
       (let* ((parent-children (split-parent-child line))
              (parent          (car parent-children))
              (children        (split-children (cadr parent-children))))
         (cons (car parent-children)
               (cond (children (mapcar #'parse-child children))
                     (t nil)))))

     (defparameter *data* (mapcar #'parse-line *day7*))

     ;;;; part 1

     (defun mk-contains-colour-p (colour)
       (lambda (entry) (assoc colour (cdr entry) :test #'string=)))

     (defun mk-get-containing-colour (colour)
       (lambda (entry)
         (when (funcall (mk-contains-colour-p colour) entry)
           (car entry))))

     (defun get-containing-colours (data &optional (colour "shiny gold"))
       (remove nil (mapcar (mk-get-containing-colour colour) data)))

     (defun remove-visited (data visited)
       (remove-if #'(lambda (x) (member (car x) visited :test #'string=)) data))

     (defun search-visited (all-visited colours data)
       (let* ((new-data (remove-visited data colours))
              (new-colours
               (mapcan #'(lambda (colour)
                           (get-containing-colours new-data colour))
                       colours)))
         (cond ((and new-colours (> (length new-data) 0))
                (search-visited (append all-visited new-colours) new-colours new-data))
               (t (remove-duplicates all-visited)))))

     ;;;; Part 2

     (defun get-contained-bags (data colour)
       "Return a list of cons cells representing the bag colours and their required
     numbers for a COLOUR bag."
       (cdr (assoc colour data :test #'string=)))

     (defun bag-counter (data item)
       "Return the number of bags + the number of bags inside each of those bags."
       (let ((bag-colour (car item))
             (num-bags   (cdr item)))
         (+ num-bags (* num-bags (count-bags-inside bag-colour data)))))

     (defun count-bags-helper (data contained-bags)
       "Apply BAG-COUNTER to each bag colour in CONTAINED-BAGS and sum the result."
       (apply #'+ (mapcar #'(lambda (item) (bag-counter data item)) contained-bags)))

     (defun count-bags-inside (colour data)
       "Count the number of bags required inside a COLOUR bag."
       (let ((contained-bags (get-contained-bags data colour)))
         (cond (contained-bags (count-bags-helper data contained-bags))
               (t 0))))

     ;;;; final

     (defun day7-part1 ()
       (length (search-visited nil (list "shiny gold") *data*)))

     (defun day7-part2 ()
       (count-bags-inside "shiny gold" *data*))

     (verbose1
       (day7-part1)
       (day7-part2))
   #+end_src

   #+RESULTS:
   : (DAY7-PART1) : -> 177
   : (DAY7-PART2) : -> 34988
   
** Day 08
   :PROPERTIES:
   :ID:       8CDD83AE-801E-483C-86AF-B40592D0E595
   :END:


   #+begin_src lisp :exports both :results output :tangle day08.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")
     (load "~/.sbclrc")
     (ql:quickload "split-sequence")

     (defun parse-instruction (line)
       (destructuring-bind (inst val) (split-sequence:split-sequence #\Space line)
         (cons (read-from-string inst) (parse-integer val))))

     (defparameter *day8* (read-file "d8.txt"))
     (defparameter *accumulator* 0)
     (defparameter *pointer* 0)
     (defparameter *instructions*
       (make-array (length *day8*) :initial-contents (mapcar #'parse-instruction *day8*)))
     (defparameter *running* t)
     (defparameter *visited* nil)

     (defun jmp (&optional (val 1)) (incf *pointer* val))

     (defun acc (val)
       (jmp)
       (incf *accumulator* val))

     (defun nop (&optional val) (jmp))

     (defun get-inst ()
       (cond ((<= 0 *pointer* (1- (length *instructions*)))
              (aref *instructions* *pointer*))
             (t
              (format t "pointer out of bounds with value ~a~%" *pointer*)
              (format t "accumulator has value: ~a.~%" *accumulator*)
              nil)))

     (defun check-visited ()
       (cond ((find *pointer* *visited*)
              (setf *running* nil)
              ,*accumulator*)
             (*running*
              (push *pointer* *visited*)
              nil)))

     (defun eval-instruction (inst)
       "Evaluate INST if non-nil."
       (let ((output-val (check-visited)))
         (cond (output-val output-val)
               (inst (funcall (car inst) (cdr inst)))
               (t nil))))

     (defun reset-runtime ()
       "Reset runtime variables to initial states."
       (setf *accumulator* 0)
       (setf *pointer* 0)
       (setf *visited* nil)
       (setf *running* t))

     ;;;; part 2

     ;;; it stands to reason that we only need to change one of the entries in
     ;;; *visited* with jmp <--> nop. That leaves <=211 possibilities
     (defun get-swap-candidates ()
       "Build list of candidates for part 2 swapping."
       (day08-part1)
       (remove-if-not #'(lambda (x) (or (eql x 'jmp) (eql x 'nop)))
                      ,*visited* :key #'get-inst-type))

     (defun get-inst-symbol (pointer-val)
       "Gets the instruction symbol associated with POINTER-VAL"
       (when (<= 0 pointer-val (1- (length *instructions*)))
         (car (aref *instructions* pointer-val))))

     (defun set-inst-symbol (pointer-val new-inst)
       "Set symbol at POINTER-VAL to NEW-INST."
       (when (or (eql 'jmp new-inst) (eql 'nop new-inst))
         (setf (aref *instructions* pointer-val)
               (cons new-inst (cdr (aref *instructions* pointer-val))))))

     (defun swap-inst-symbol (pointer-val)
       "Swap 'JMP for 'NOP and vice versa at POINTER-VAL (or return NIL)."
       (let ((inst-func (get-inst-symbol pointer-val)))
         (cond ((eql inst-func 'jmp) (set-inst-symbol pointer-val 'nop))
               ((eql inst-func 'nop) (set-inst-symbol pointer-val 'jmp))
               (t nil))))

     (defun eval-if-valid ()
       "Eval instruction associated with *pointer* only if *pointer* is
     valid. Otherwise, stop runtime and return *accumulator* value."
       (cond ((<= 0 *pointer* (1- (length *instructions*)))
              (eval-instruction (get-inst)))
             (t (setf *running* nil)
                ,*accumulator*)))

     (defun execute-swapped-runtime (swap-index)
       (reset-runtime)
       (swap-inst-symbol swap-index)
       (let ((result
              (loop until (not *running*)
                 for x = (eval2-if-valid)
                 finally (return x))))
         (swap-inst-symbol swap-index) ;; swap back!
         result))

     ;;;; final

     (defun day08-part1 ()
       (reset-runtime)
       (loop until (not *running*)
          for x = (eval-instruction (get-inst))
          finally (return x)))


     (defun day08-part2 ()
       (loop for swap-idx in (get-swap-candidates)
          for x = (execute-swapped-runtime swap-idx)
          until x
          finally (return x)))

     (verbose1
       (day08-part1)
       (day08-part2))
   #+end_src

   #+RESULTS:
   : (DAY08-PART1) : -> 1451
   : (DAY08-PART2) : -> 1160
   
** Day 09
   :PROPERTIES:
   :ID:       F755144D-8EBA-4839-A607-8EBCA4249F06
   :END:


   #+begin_src lisp :exports both :results output :tangle day09.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")

     ;;;; def

     (defparameter *day9* (mapcar #'read-from-string (read-file "d9.txt")))
     (defparameter *preamble (subseq *day9* 0 25))
     (defparameter *numbers* (make-array (length *day9*) :initial-contents *day9*))
     (defparameter *cur* 25)
     (defparameter *magic-number* 177777905)

     ;;;; part 1

     (defun range (n &key (start 0))
       (when (and (numberp n) (>= n 0))
         (loop for i from start below n collect i)))

     (defun validate-at-index (index)
       (when (>= (1- (length *numbers*)) index 25)
         (let ((prev (subseq *numbers* (- index 25) index))
               (cur (aref *numbers* index)))
           (loop for a across prev
              do (loop for b across prev
                    if (and (/= b a) (= (+ b a) cur))
                    do (return-from validate-at-index (+ b a)))))))

     ;;;; part 2

     (defun too-small-p (value)
       (< value *magic-number*))

     (defun too-large-p (value)
       (> value *magic-number*))

     (defun get-value (index)
       (aref *numbers* index))

     (defparameter *contig* nil)

     (defun append-right (value) (setf *contig* (append *contig* (list value))))

     (defun pop-left ()
       (let ((ret (car *contig*)))
         (setf *contig* (cdr *contig*))
         ret))

     (defun get-sum ()
       (apply #'+ *contig*))

     (defun search-for-contiguous-sum (&optional (left-idx 0) (right-idx 0))
       "Find a contiguous block of numbers whose sum is equals *MAGIC-NUMBER* (found in Part 1)."
         (cond ((too-small-p (get-sum))              ; if the sum is too small, 
                (append-right (get-value right-idx)) ; add the next number to the block
                (search-for-contiguous-sum left-idx (1+ right-idx))) ; & try again
               ((too-large-p (get-sum)) ; if the sum is too small,
                (pop-left)              ; remove the first number in the block
                (search-for-contiguous-sum (1+ left-idx) right-idx)) ; & try again
               ((>= (length *contig*) 2) ; >= 2 contiguous numbers with desired sum
                (+ (apply #'min *contig*) (apply #'max *contig*))) ; yay!
               (t (append-right (get-value right-idx))     ; keep trying!
                  (search-for-contiguous-sum left-idx (1+ right-idx)))))

     ;;;; final

     (defun day09-part1 ()
       (let ((indices (range (length *numbers*) :start 25)))
         (loop for index in indices
            while (validate-at-index index)
            finally (return (aref *numbers* index)))))

     (defun day09-part2 ()
       (defparameter *contig* nil)
       (search-for-contiguous-sum))

     (verbose1
       (day09-part1)
       (day09-part2))
   #+end_src

   #+RESULTS:
   : (DAY09-PART1) : -> 177777905
   : (DAY09-PART2) : -> 23463012
   

*** Notes

    There is a potential bottleneck in ~APPEND-RIGHT~. Namely, I'm using ~APPEND~ to
    add an element to the end of a list. If the list is long, and/or the
    function is called a lot this could slow things down (because ~APPEND~ has to
    traverse the whole list each time). A way of speeding this up (subject to a
    bit of added complexity) is available in [[https://stackoverflow.com/a/6482598/1456421][this SO post]]. For example,

    #+begin_src lisp :exports both :results output
      (defparameter *contig* nil)
      (defparameter *contig-tail* *contig*)

      ;;; if *contig* is nil it has no tail and so we can't append-right;
      ;;; do a normal PUSH instead.
      (defun append-right--contig (value)
        (cond (*contig-tail*
               (setf (cdr *contig-tail*) (cons value nil))
               (setf *contig-tail* (cdr *contig-tail*)))
              (t (push value *contig*)
                 (setf *contig-tail* *contig*))))

      ;;; APPEND-RIGHT only makes sense when the list is non-nil, else there is no
      ;;; "right" to append to. In this case, start with a usual PUSH and then use
      ;;; APPEND-RIGHT.
      (defun append-right (tail value)
        (when tail
          (setf (cdr tail) (cons value nil))
          (setf tail (cdr tail))
          tail))

      ;;;; Example
      (append-right--contig 0)
      (append-right--contig 1)
      (append-right--contig 2)
      (append-right--contig 3)

      (format t "~{~a~^, ~}~%" *contig*)
      (format t "~{~a~^, ~}~%" *contig-tail*)
    #+end_src

    #+RESULTS:
    : 0, 1, 2, 3
    : 3

** Day 10
   :PROPERTIES:
   :ID:       660CD373-3858-4F42-AEF5-C044B4E5E0E9
   :END:

   #+begin_src lisp :exports both :results output :tangle day10.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")
     (load "~/.sbclrc")
     (ql:quickload "split-sequence")

     (defparameter *day10* (mapcar #'parse-integer (read-file "d10.txt")))
     (defparameter *device-joltage* (+ 3 (apply #'max *day10*)))


     (defun sorted-joltages ()
       (sort (copy-seq *day10*) #'<))

     (defparameter *sorted-joltages*
       (append (list 0) (sorted-joltages) (list *device-joltage*))
       "Includes outlet joltage and device joltage")

     ;;;; Part 1

     (defun diff-func (seq)
       "Compute x1 - x0 where x0 is the first element of SEQ."
       (if (cadr seq)
           (- (cadr seq) (car seq))
           nil))

     (defun diff (seq)
       "Computes the differences between consecutive elements in SEQ."
       (remove nil (maplist #'diff-func seq)))


     ;;;; Part 2

     (defparameter *tribonacci-alist* nil)

     (defun compute-tribonacci--alist (n)
       "Return n-th tribonacci number, computing recursively and using alist
     memoization. Helper function for tribonacci--alist."
       (let ((t-n (+ (tribonacci--alist (- n 1))
                     (tribonacci--alist (- n 2))
                     (tribonacci--alist (- n 3)))))
         (push (cons n t-n) *tribonacci-alist*)
         t-n))

     (defun tribonacci--alist (n)
       "Return the nth tribonacci number using memoization for speed-up."
       (cond
         ((or (not (numberp n)) (< n 0)) (format t "N must be a nonnegative integer.~%"))
         ((<= 0 n 1) 1) ((= n 2) 2)
         ((> n 2)
          (let ((t-n (cdr (assoc n *tribonacci-alist*))))
            (if t-n t-n
                (compute-tribonacci--alist n))))))


     ;;;; final

     (defun day10-part1 ()
       (let ((diffs (diff *sorted-joltages*)))
         (* (count 1 diffs) (count 3 diffs))))

     (defun day10-part2 ()
       "We can view the effect of removing adapters through the diffs. Namely, it's
     equivalent to 'merging' contiguous 1s into 2s or 3s (and no higher, as per the
     problem requirements). It so happens that finding the number of possible
     mergings for a contiguous block of 1s of length n is given by the nth tribonacci
     number. Simply multiply together the tribonacci number associated to each
     contiguous block of 1s to obtain the result.

     Examples are provided for contiguous 1 blocks of length 1 through 5:

     1  [1]: (1)
     2  [2]: (1 1)       (2)
     3  [4]: (1 1 1)     (2 1)     (1 2)      (3)
     4  [7]: (1 1 1 1)   (2 1 1)   (1 2 1)    (1 1 2)   (2 2)     
             (3 1)       (1 3)
     5 [13]: (1 1 1 1 1) (2 1 1 1) (1 2 1 1)  (1 1 2 1) (1 1 1 2)
             (2 2 1)     (2 1 2)   (1 2 2)    (3 1 1)   (1 3 1)   
             (1 1 3)     (3 2)     (2 3)"
       (let* ((diffs (diff *sorted-joltages*))
              (contig-1s (split-sequence:split-sequence 3 diffs))
              (block-lengths (remove 0 (mapcar #'length contig-1s))))
         (apply #'* (mapcar #'tribonacci--alist block-lengths))))

     (verbose1
       (day10-part1)
       (day10-part2))
   #+end_src

   #+RESULTS:
   : (DAY10-PART1) : -> 1980
   : (DAY10-PART2) : -> 4628074479616


   #+begin_src lisp :exports both :results output
     ;;; hash table implementation of the tribonacci function, just for fun.

     (defparameter *tribonacci-hash* (make-hash-table))

     (defun compute-tribonacci--hash (n)
       "Return n-th tribonacci number, computing recursively and using hash table
     memoization. Helper function for tribonacci--hash."
       (setf (gethash n *tribonacci-hash*)
             (+ (tribonacci--hash (- n 1))
                (tribonacci--hash (- n 2))
                (tribonacci--hash (- n 3)))))

     (defun tribonacci--hash (n)
       "Return the nth tribonacci number using memoization for speed-up."
       (when n
         (cond
           ((or (not (numberp n)) (< n 0)) (format t "N must be a nonnegative integer.~%"))
           ((<= 0 n 1) 1) ((= n 2) 2)
           ((> n 2)
            (let ((t-n (gethash n *tribonacci-hash*)))
              (if t-n t-n (compute-tribonacci--hash n)))))))
   #+end_src

** Day 11
   :PROPERTIES:
   :ID:       6C47E0CA-9A6B-436A-A5EC-11A1BA478206
   :END:

   #+begin_src lisp :exports both :results output :tangle day11.lisp :shebang "#!/usr/bin/env sbcl --script"
     (defparameter *day11* (read-file "d11.txt"))
     (defparameter *m* (length *day11*))
     (defparameter *n* (length (car *day11*)))
     (defparameter *seats* (make-array (list *m* *n*)))

     (defun seating-char->num (elem)
       "Convert ELEM from numerical to character representation.
         0 <-> #\L
         1 <-> #\#
        -1 <-> #\. "
       (cond ((char= elem #\L) 0)
             ((char= elem #\#) 1)
             ((char= elem #\.) -1)
             (t nil)))

     (defun seating-num->char (elem)
       "Convert ELEM from character to numerical representation.
         0 <-> #\L
         1 <-> #\#
        -1 <-> #\. "
       (cond ((= elem 0) #\L)
             ((= elem 1) #\#)
             ((= elem -1) #\.)
             (t nil)))

     (defun print-seating (seating)
       "Print a SEATING that has been converted to 'num' type."
       (let ((converted (mapcar #'(lambda (row) (mapcar #'seating-num->char row)) seating)))
         (format t "~{~{~a~}~%~}~%" converted)))

     (defun print-seats-arr ()
       (loop for i from 0 below *m*
          do (progn
               (loop for j from 0 below *n*
                  do (format t "~a" (seating-num->char (aref *seats* i j))))
               (fresh-line)))
       (format t "~%~%"))

     (defun initialize-seating-arr ()
       "Set the elements of *SEATS* to their initial values."
       (loop for row in *day11* for i from 0
          do (loop for elem across row for j from 0
                do (setf (aref *seats* i j) (seating-char->num elem)))))

     ;;;; Part 1


     (defun get-elem (idx)
       "Return the element of *SEATS* given by IDX, which is a CONS cell with
        format (ROW . COLUMN)."
       (aref *seats* (car idx) (cdr idx)))

     (defmacro test-elem (idx val)
       "Boilerplate for testing whether the IDX element of *SEATS* has value VAL."
       `(= (get-elem ,idx) ,val))

     (defun empty-seat-p (idx) (test-elem idx 0))

     (defun filled-seat-p (idx) (test-elem idx 1))

     (defun seat-p (idx)
       "Predicate returning T if element IDX is a seat."
       (or (empty-seat-p idx) (filled-seat-p idx)))

     (defun floor-p (idx) (test-elem idx -1))

     (defun neighbour-relative-positions ()
       "Helper function returning the <=8 neighbouring indices about an index."
       (apply #'append
              (loop for i from -1 to 1
                 collect (loop for j from -1 to 1
                            unless (and (= i 0) (= j 0))
                            collect (cons i j)))))

     (defun idx-oob-p (idx)
       "Checks if index IDX is 'out of bounds'. IDX has the form (ROW . COLUMN),
        where 0 <= ROW < *m* and 0 <= COLUM < *n*."
       (or (or (< (car idx) 0) (>= (car idx) *m*))
           (or (< (cdr idx) 0) (>= (cdr idx) *n*))))

     (defun idx+ (idx1 idx2)
       "Add two indices IDX1 and IDX2."
       (cons (+ (car idx1) (car idx2))
             (+ (cdr idx1) (cdr idx2))))

     (defun get-neighbouring-indices (idx)
       "Get indices representing neighbours of IDX."
       (remove-if
        #'idx-oob-p
        (mapcar #'(lambda (ij) (idx+ idx ij))
                (neighbour-relative-positions))))

     (defun get-neighbouring-values (idx)
       "Get values stored in neighbouring indices of IDX."
       (mapcar #'get-elem (get-neighbouring-indices idx)))

     (defun num-neighbours-occupied (idx)
       "Count number of neighbours that are occupied seats."
       (count 1 (get-neighbouring-values idx)))

     (defun set-elem (idx value)
       "Set element IDX of *SEATS* to VALUE."
       (setf (aref *seats* (car idx) (cdr idx)) value))

     (defun update-seat (idx)
       "Apply seat update rule to element IDX of *SEATS*."
       (cond ((and (empty-seat-p idx) (= 0 (num-neighbours-occupied idx))) 1)
             ((and (filled-seat-p idx) (<= 4 (num-neighbours-occupied idx))) 0)
             (t (get-elem idx))))

     (defun get-new-seating (&optional (seating-update-func #'update-seat))
       "Determine new seating by applying update rules simultaneously to all elements
        of *SEATS*."
       (loop for i from 0 below *m*
          collect (loop for j from 0 below *n*
                     collect (funcall seating-update-func (cons i j)))))

     (defun update-seating (new-seating)
       "Update seating arrangement by setting *SEATS* to be the result of
        GET-NEW-SEATING."
         (loop for row in new-seating
            for i from 0
            do (loop for elem in row
                  for j from 0
                  do (set-elem (cons i j) elem))))

     (defun seating= (new-seating)
       "Compare NEW-SEATING to *SEATS*, returning T if all elements are equal."
       (loop for new-row in new-seating
          for i from 0
          do (loop for new-elem in new-row
                for j from 0
                do (when (/= new-elem (get-elem (cons i j))) (return-from seating= nil))))
       t)

     (defun count-occupied ()
       "Count number of occupied seats in *SEATS*."
       (loop for i from 0 below *m*
          summing (loop for j from 0 below *n*
                     counting (= (get-elem (cons i j)) 1))))


     ;;;; Part 2

     (defun idx* (idx alpha)
       "Multiply IDX by a scalar ALPHA."
       (cons (* (car idx) alpha) (* (cdr idx) alpha)))

     (defun relative-neighbour (idx slope r)
       "Get a 'neighbour' along SLOPE from IDX at l1-radius R."
       (idx+ idx (idx* slope r)))

     (defun first-chair-along-ray (idx slope)
       "Return chair status (i.e. 0 or 1) for first chair found along a ray with
        slope SLOPE beginning from IDX (not including IDX). Return -1 if no chair
        found."
       (loop for r from 1
          for neighbour = (relative-neighbour idx slope r)
          until (idx-oob-p neighbour)
          if (seat-p neighbour)
          do (return-from first-chair-along-ray (get-elem neighbour))
          finally (return -1)))

     (defun occupancy-in-lines-of-sight (idx)
       "Return list of chair occupancy along all <=8 lines of sight."
       (mapcar
        #'(lambda (slope) (first-chair-along-ray idx slope))
        (neighbour-relative-positions)))

     (defun num-visible-occupancy (idx)
       "Count number of visibly occupied chairs along all <= 8 lines of sight."
       (count 1 (occupancy-in-lines-of-sight idx)))

     (defun no-visible-occupancy-p (idx)
       (= 0 (num-visible-occupancy idx)))

     (defun update-seat2 (idx)
       "Apply 2nd seat update rule to element IDX of *SEATS*."
       (cond ((and (empty-seat-p idx) (no-visible-occupancy-p idx)) 1)
             ((and (filled-seat-p idx) (<= 5 (num-visible-occupancy idx))) 0)
             (t (get-elem idx))))

     (defun occupancy-los-array ()
       "For debugging. Make an array containing the number of visibly occupied chairs
     from each index in *SEATS*."
       (loop for i from 0 below *m*
          collect (loop for j from 0 below *n*
                     collect (num-visible-occupancy (cons i j)))))

     (defun print-occupancy-los-array ()
       "For debugging. Print an array containing the number of visibly occupied
     chairs from each index in *SEATS*."
       (let ((occupancy-arr (occupancy-los-array)))
         (format t "Occupancy-LOS-array:~%~{~{~a~}~%~}~%" occupancy-arr)))

     ;;;; final

     (defun day11-part1 ()
       (initialize-seating-arr)
       (let ((new-seating (get-new-seating)))
         (loop until (seating= new-seating)
            do (progn
                 (update-seating new-seating)
                 (setf new-seating (get-new-seating)))
            finally (return (count-occupied)))))

     (defun day11-part2 ()
       (initialize-seating-arr)
       (let ((new-seating (get-new-seating #'update-seat2)))
         (loop until (seating= new-seating)
            do (progn
                 (update-seating new-seating)
                 (setf new-seating (get-new-seating #'update-seat2)))
            finally (return (count-occupied)))))

     (verbose1
       (day11-part1)
       (day11-part2))
   #+end_src

   #+RESULTS:
   : (DAY11-PART1) : -> 2113
   : (DAY11-PART2) : -> 1865
   

** Day 12
   :PROPERTIES:
   :ID:       72A5D375-16BC-4C15-AFF6-EB2E885D129A
   :END:


   #+begin_src lisp :exports both :results output :tangle day12.lisp :shebang "#!/usr/bin/env sbcl --script"
     (defparameter *day12* (read-file "d12.txt"))
     (defparameter *theta* 0 "Ship angle (initially aligned with x axis)")
     (defparameter *x* 0 "Ship x position")
     (defparameter *y* 0 "Ship y position")

     (defun re-initialize-parms ()
       (setf *theta* 0)
       (setf *x* 0)
       (setf *y* 0))

     (defun deg->rad (degrees)
       (* degrees (/ pi 180)))

     (defun rotate (angle) (setf *theta* (- (mod (+ 180 (+ *theta* angle)) 360) 180)))
     (defun rotate-right (angle) (rotate (- angle)))
     (defun rotate-left (angle) (rotate angle))

     (defun move-forward (distance)
       (incf *x* (* (cos (deg->rad *theta*)) distance))
       (incf *y* (* (sin (deg->rad *theta*)) distance)))

     (defun move-north (distance) (incf *y* distance))
     (defun move-south (distance) (incf *y* (- distance)))
     (defun move-east (distance) (incf *x* distance))
     (defun move-west (distance) (incf *x* (- distance)))

     (defun search-for (letter string)
       (some #'(lambda (x) (char-equal x letter)) string))

     (defun parse-action (line)
       (cond ((search-for #\r line) #'rotate-right)
             ((search-for #\l line) #'rotate-left)
             ((search-for #\n line) #'move-north)
             ((search-for #\s line) #'move-south)
             ((search-for #\e line) #'move-east)
             ((search-for #\w line) #'move-west)
             ((search-for #\f line) #'move-forward)
             (t nil)))


     (defun parse-distance (line)
       (parse-integer (subseq line 1)))

     (defun eval-line (line &optional (action-parser #'parse-action))
       (let ((action (funcall action-parser line)))
         (when action
           (funcall action (parse-distance line)))))

     (defun manhattan-dist ()
       (floor (+ (abs *x*) (abs *y*))))


     ;;;; Part 2

     (defparameter *wp-x* 10 "way-point x position")
     (defparameter *wp-y* 1 "way-point y position")

     (defun waypoint-radius ()
       (sqrt (+ (expt *wp-x* 2) (expt *wp-y* 2))))

     (defun waypoint-angle ()
       (let ((principal (atan (/ *wp-y* *wp-x*))))
         (cond ((and (< *wp-x* 0) (< *wp-y* 0)) (- principal pi))
               ((< *wp-x* 0) (+ principal pi))
               (t principal))))

     (defun rotate-waypoint-right (angle)
       (let ((radius (waypoint-radius))
             (theta (- (waypoint-angle) (deg->rad angle))))
         (setf *wp-x* (* radius (cos theta)))
         (setf *wp-y* (* radius (sin theta)))))

     (defun rotate-waypoint-left (angle)
       (rotate-waypoint-right (- angle)))

     (defun move-waypoint-north (distance) (incf *wp-y* distance))
     (defun move-waypoint-south (distance) (incf *wp-y* (- distance)))
     (defun move-waypoint-east (distance) (incf *wp-x* distance))
     (defun move-waypoint-west (distance) (incf *wp-x* (- distance)))
     (defun move-waypointward (distance)
       (incf *x* (* distance *wp-x*))
       (incf *y* (* distance *wp-y*)))

     (defun parse-action2 (line)
       (cond ((search-for #\r line) #'rotate-waypoint-right)
             ((search-for #\l line) #'rotate-waypoint-left)
             ((search-for #\n line) #'move-waypoint-north)
             ((search-for #\s line) #'move-waypoint-south)
             ((search-for #\e line) #'move-waypoint-east)
             ((search-for #\w line) #'move-waypoint-west)
             ((search-for #\f line) #'move-waypointward)
             (t nil)))

     ;;;; final

     (defun day12-part1 ()
       (loop for line in *day12*
          do (eval-line line)
          finally (return (manhattan-dist))))

     (defun day12-part2 ()
       (re-initialize-parms)
       (loop for line in *day12*
          do (eval-line line #'parse-action2)
          finally (return (manhattan-dist))))

     (verbose1
       (day12-part1)
       (day12-part2))
   #+end_src

   #+RESULTS:
   : (DAY12-PART1) : -> 1319
   : (DAY12-PART2) : -> 62434
   
** Day 13
   :PROPERTIES:
   :ID:       9835D616-A57F-4957-9F60-3282E6300270
   :END:

   #+begin_src lisp :exports both :results output :tangle day13.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "~/.sbclrc")
     (ql:quickload "split-sequence")

     (defparameter *day13* (read-file "d13.txt"))
     (defparameter *my-arr-time* (parse-integer (car *day13*)))

     (let ((bus-nums (mapcar
                      #'(lambda (x) (parse-integer x :junk-allowed t))
                      (split-sequence:split-sequence #\, (cadr *day13*)))))
       (defparameter *bus-numbers* (remove nil bus-nums))
       (defparameter *bus-positions*
         (loop for elem in bus-nums for i from 0
            if elem collect i)))

     (defun waiting-time (my-arr-time bus-loop-duration)
       "Find amount of time you need to wait for the bus to take you to the airport."
       (- bus-loop-duration (mod my-arr-time bus-loop-duration)))

     (defun argmin-helper (func &optional x y)
       "Return X if (FUNC X) < (FUNC Y) else return Y."
       (cond ((and x y)
              (let ((fx (funcall func x))
                    (fy (funcall func y)))
                (if (> fx fy) y x)))
             (x x)))

     (defun argmin (func &rest args)
       "Return the element of ARGS that minimizes FUNC."
       (cond ((<= (length args) 2) (apply #'argmin-helper func args))
             (t (destructuring-bind (x y &rest rest) args
                  (apply #'argmin func (cons (argmin-helper func x y) rest))))))


     ;;;; Part 2

     (defun egcd (a b)
       "Extended Euclidean algorithm. Return (r s t) where r is remainder and (s t)
       are such that s*a + t*b = r."
       ;; update rule looks like r_{i+1} = q*r_{i+1} - r_{i}
       (do ((r (cons b a) (cons (- (cdr r) (* (car r) q)) (car r))) ; (new-r old-r)
            (s (cons 0 1) (cons (- (cdr s) (* (car s) q)) (car s))) ; (new-s old-s)
            (u (cons 1 0) (cons (- (cdr u) (* (car u) q)) (car u)))); (new-t old-t)
           ;; iterate until r_{I+1} = 0; return (r_{I} s_{I} t_{I})
           ((zerop (car r)) (values (cdr r) (cdr s) (cdr u)))
         ;; update quotient q
         (setf q (floor (cdr r) (car r)))))

     (defun invmod (a m)
       "Return the inverse of a-inverse(mod m). Throw error if (a m) not co-prime."
       (multiple-value-bind (r s u) (egcd a m)
         (unless (= 1 r) (error "invmod: Values ~a and ~a are not co-prime." a m))
         s))

     (mapcar #'cdr (list '(1 . 2) '(3 . 4)))

     (defun chinese-remainder (am)
       "am is a list of cons cells where the integers are the cars and the moduli are
       the cdrs."
       (loop for (a . m) in am
          with prod-m = (apply #'* (mapcar #'cdr am))
          and result = 0
          for yi = (/ prod-m m)
          for zi = (invmod yi m)
          finally (return (mod result prod-m))
          do (incf result (* a yi zi))))

     ;;;; final

     (defun day13-part1 ()
       (let ((best-bus-number
              (apply
               #'argmin
               #'(lambda (bus-number)
                   (waiting-time *my-arr-time* bus-number))
               ,*bus-numbers*)))
         (* best-bus-number (waiting-time *my-arr-time* best-bus-number))))


     (defun day13-part2 ()
       "Goal is to find tstamp + offset_i \cong 0(mod bus-number_i). Compute this
        using the chinese remainder theorem with integers a given by the negative of
        the bus-positions, and the moduli m given as the bus numbers (which are all
        prime)."
       (chinese-remainder (pairlis (mapcar #'- *bus-positions*) *bus-numbers*)))

     (verbose1
       (day13-part1)
       (day13-part2))
   #+end_src

   #+RESULTS:
   : (DAY13-PART1) : -> 261
   : (DAY13-PART2) : -> 807435693182510

** Day 14
   :PROPERTIES:
   :ID:       E0B60C09-12A7-4E6C-BB88-85B234BE1B18
   :END:

   #+begin_src lisp :exports both :results output :tangle day14.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "~/.sbclrc")
     (ql:quickload "split-sequence")

     (defparameter *day14* (read-file "d14.txt"))


     ;;;; Part 1

     (defparameter *zero-mask* nil)
     (defparameter *one-mask* nil)

     (defun get-mask (line)
       (let ((split-line (split-sequence:split-sequence #\Space line)))
         (when (string= (car split-line) "mask")
           (car (last split-line)))))

     (defun set-mask (mask-string)
       (when mask-string
         (setf *zero-mask* 0)
         (setf *one-mask* 0)
         (loop for c across mask-string
            for i from 35 downto 0
            if (char= c #\0)
            do (incf *zero-mask* (expt 2 i))
            if (char= c #\1)
            do (incf *one-mask* (expt 2 i))
            finally (return (values *zero-mask* *one-mask*)))))

     (defun update-mask (line)
       (let ((mask-string (get-mask line)))
         (set-mask mask-string)))

     (defun parse-mem-line (line)
       (if (get-mask line) (cons nil nil)
           (let* ((address-value (split-sequence:split-sequence #\= line))
                  (address (remove-if-not #'digit-char-p (car address-value)))
                  (value (remove-if-not #'digit-char-p (cadr address-value))))
             (cons (parse-integer address) (parse-integer value)))))

     (defun apply-bitmask (value)
       (logior *one-mask* (logand (lognot *zero-mask*) value)))

     (defun eval-mem-line (line)
       (destructuring-bind (address . value) (parse-mem-line line)
         (when (and address value)
           (cons address (apply-bitmask value)))))


     ;;;; Part 2

     (defparameter *1s-mask* 0) ; to force bits to 1
     (defparameter *0s-mask* 0) ; to keep the values that remain unchanged
     (defparameter *floating-mask-bits* nil)
     (defparameter *floating-masks* nil)


     (defun powerset (s)
       "See https://rosettacode.org/wiki/Power_set#Common_Lisp"
       (if s (mapcan (lambda (x) (list (cons (car s) x) x)) 
                     (powerset (cdr s))) 
           '(())))

     (defun set-floating-masks-from-bits ()
       (loop for bit-set in (powerset *floating-mask-bits*)
          do (push (loop for b in bit-set summing (expt 2 b)) *floating-masks*)))

     (defun set-floating-mask (mask-string)
       (when mask-string
         (setf *1s-mask* 0)
         (setf *0s-mask* 0)
         (setf *floating-mask-bits* nil)
         (setf *floating-masks* nil)
         (loop for c across mask-string
            for i from 35 downto 0
            if (char= c #\X)
            do (push i *floating-mask-bits*)
            if (char= c #\0)
            do (incf *0s-mask* (expt 2 i))
            if (char= c #\1)
            do (incf *1s-mask* (expt 2 i))
            finally (set-floating-masks-from-bits))))

     (defun update-masks2 (line)
       "Update masks for floating bit mask challenge (part 2)."
       (let ((mask-string (get-mask line)))
         (set-floating-mask mask-string)))

     (defun mem-addr-decode (address)
       (when (and address *floating-masks*)
         (let ((root-address (logior *1s-mask* (logand address *0s-mask*))))
           (mapcar #'(lambda (x) (logior root-address x)) *floating-masks*))))

     (defun eval-mem-line2 (line)
       (destructuring-bind (address . value) (parse-mem-line line)
         (when (and address value)
           (mapcar #'(lambda (addr) (cons addr value)) (mem-addr-decode address)))))

     ;;;; final

     (defun day14-part1 ()
       (loop
          for (addr . value) in
            (remove-duplicates
             (loop for line in *day14*
                for addr-val = (eval-mem-line line)
                do (update-mask line)
                if (numberp (car addr-val))
                collect addr-val)
             :key #'car)
          summing value))

     (defun day14-part2 ()
       (loop
          for key being the hash-keys of
            (loop with my-memory = (make-hash-table :size 1000)
               for line in *day14*
               for addr-val-list = (eval-mem-line2 line)
               do (update-masks2 line)
               if addr-val-list
               do (loop for (addr . val) in addr-val-list
                     do (setf (gethash addr my-memory) val))
               finally (return my-memory))
          using (hash-value value)
          summing value))

     (verbose1
       (day14-part1)
       (day14-part2))
   #+end_src

   #+RESULTS:
   : (DAY14-PART1) : -> 6317049172545
   : (DAY14-PART2) : -> 3434009980379
   

** Day 15
   :PROPERTIES:
   :ID:       1C5F03F7-B9E3-4B50-BBEA-D17F63A7E7A3
   :END:

   #+begin_src lisp :exports both :results output :tangle day15.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")
     (defparameter *day15* (list 1 12 0 20 8 16))
     (defparameter *last-number* 16 "The last number that was spoken")
     (defparameter *turn* 6 "The last turn number")
     (defparameter *alist* nil)

     (defun re-initialize ()
       (setf *alist* nil)
       (setf *last-number* 16)
       (setf *turn* 6)
       (loop for key in *day15* for value from 1
          do (push (cons key value) *alist*)))

     (defun empty-alist ()
       (setf *alist* nil))

     (defun cdr- (c1 c2)
       (if (and c1 c2)
           (- (cdr c1) (cdr c2))
           0))

     (defun next-number ()
       (cdr- (assoc *last-number* *alist*)
             (assoc *last-number* (cdr *alist*))))

     (defun update-alist ()
       (incf *turn*)
       (push (cons (next-number) *turn*) *alist*)
       (setf *last-number* (caar *alist*))
       (car *alist*))

     ;;;; Part 2

     ;;; alists were fine for part 1, but part 2 is too big and we must use a hash
     ;;; table afterall.

     (defparameter *hashmap* (make-hash-table :size 10000))
     (defparameter *cur* (cons 16 6) "current number")

     (defun get-hashkeys ()
       (let ((keys nil))
         (maphash #'(lambda (k v) (push k keys)) *hashmap*)
         keys))

     (defun empty-hashmap ()
       (let ((keys (get-hashkeys)))
         (dolist (k keys)
           (remhash k *hashmap*))))

     (defmacro set-hash (key value)
       `(setf (gethash ,key *hashmap*) ,value))

     (defun re-initialize2 ()
       (setf *cur* (cons 16 6))
       (setf *turn* 6)
       (empty-hashmap)
       (loop for key in *day15* for value from 1
          do (set-hash key value)))

     (defun print-hashkeys ()
       (maphash #'(lambda (k v) (format t "k: ~a v: ~a~%" k v)) *hashmap*)
       (format t "----~%"))

     (defun next-number ()
       (let ((last-seen (gethash (car *cur*) *hashmap*)))
         (if last-seen
             (- (cdr *cur*) last-seen)
             0)))

     (defun update-hash ()
       (let ((tmp-cur *cur*))
         (setf *cur* (cons (next-number) (incf *turn*)))
         (set-hash (car tmp-cur) (cdr tmp-cur))))

     ;;;; final

     (defun day15-part1 (&optional (end-num 2020))
       (re-initialize)
       (loop until (>= *turn* end-num)
          do (update-alist)
          finally (return (rassoc end-num *alist*))))

     (defun day15-part2 ()
       (re-initialize2)
       (loop until (= (cdr *cur*) 30000000)
          do (update-hash)
          finally (return *cur*)))

     (verbose1
       (day15-part1)
       (day15-part2))

   #+end_src

   #+RESULTS:
   : (DAY15-PART1) : -> (273 . 2020)
   : (DAY15-PART2) : -> (47205 . 30000000)
   

** Day 16
   :PROPERTIES:
   :ID:       35D53489-4931-488A-9CF0-19596E8A8B95
   :END:


   #+begin_src lisp :exports both :results output :tangle day16.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")
     (load "~/.sbclrc")
     (ql:quickload "split-sequence")

     (defparameter *day16* (read-file "d16.txt"))

     (defparameter *ticket-field-rules*
       (loop for line in *day16*
          for line-length = (length line)
          for i from 0
          until (zerop line-length)
          if (not (zerop line-length))
          collect line))

     (defun parse-ticket (ticket)
       (mapcar #'parse-integer (split-sequence:split-sequence #\, ticket)))

     (defparameter *your-ticket*
       (parse-ticket
        (cadr
         (loop for line in *day16*
            for line-length = (length line)
            with read-flag = nil
            if (and read-flag (> line-length 0))
            collect line
            if (zerop line-length)
            do (setf read-flag (not read-flag))
            until (search "nearby ticket" line)))))

     (defparameter *nearby-tickets*
       (mapcar #'parse-ticket
               (loop for line in *day16*
                  with read-flag = nil
                  if read-flag
                  collect line
                  if (search "nearby ticket" line)
                  do (setf read-flag t))))


     (defun to-cons (list)
       "Take a two element list '(A B) and return a dotted pair (A . B)."
       (when (eql 2 (length list))
         (setf (cdr list) (cadr list)))
       list)

     (defun valid-range (ticket-field-rule)
       (let* ((range-string (cadr (split-sequence:split-sequence #\: ticket-field-rule)))
              (ranges-list (split-sequence:split-sequence #\Space range-string))
              (range-pairs
               (remove-if
                #'(lambda (x) (or (zerop (length x)) (not (find #\- x))))
                ranges-list)))
         (mapcar #'(lambda (x)
                     (to-cons (mapcar #'parse-integer
                                      (split-sequence:split-sequence #\- x))))
                 range-pairs)))

     (defun dotted-pair-p (list)
       "Return T if list is a dotted pair CONS cell (A . B) and NIL otherwise."
       (and (listp list) (not (listp (cdr list)))))

     (defun interval-union (i1 i2)
       "I1 and I2 are CONS cells with (CAR I1) < (CAR I2)."
       (cond ((null i1) i2)
             ((null i2) i1)
             ((<= (cdr i2) (cdr i1)) i1) ; i1lo <= i2lo <= i2up <= i1up
             ((<= (car i2) (cdr i1)) (cons (car i1) (cdr i2))) ; i1lo <= i2lo <= i1up <= i2up
             (t (list i1 i2))))

     (defun unionize (i1 i2 &rest intervals)
       "Simplify a collection of intervals into a union (i.e. LIST) of
        non-overlapping intervals (i.e. CONS cells)."
       (let ((i12 (interval-union i1 i2)))
         (cond ((null intervals) i12)
               ((dotted-pair-p i12)
                (push i12 intervals)
                (apply #'unionize intervals))
               (t
                (push (cadr i12) intervals)
                (append (list (car i12)) (apply #'unionize intervals))))))

     (defparameter *valid-range*
       (apply #'unionize
              (sort
               (apply #'append (mapcar #'valid-range *ticket-field-rules*))
               #'< :key #'car))
       "An interval (i.e. CONS cell) whose CAR is the lower end of the valid range,
       and CDR is the upper end of the valid range (as defined by part 1 of this
       challenge).")

     (defun in-interval (value interval)
       "Return T if value is in the interval INTERVAL."
       (when (dotted-pair-p interval)
         (<= (car interval) value (cdr interval))))

     (defun in-uoi (value uoi)
       "Return T if VALUE is in the union of intervals UOI."
       (cond ((dotted-pair-p uoi) (in-interval value uoi))
             ((listp uoi) (some #'(lambda (x) (in-interval value x)) uoi))
             (t (error "in-range: Unexpected condition reached; *valid-range* is not
             a list or dotted pair"))))

     (defun in-range (value)
       (in-uoi value *valid-range*))


     ;;;; Part 2

     (defparameter *valid-tickets*
       (remove-if
        #'(lambda (ticket)
            (notevery #'(lambda (value) (in-range value))
                      ticket))
        ,*nearby-tickets*))
     (push *your-ticket* *valid-tickets*) ;; 191 tickets



     (defun get-ticket-field-ranges ()
       (mapcar #'valid-range *ticket-field-rules*))

     (defun possible-slots (ticket-field-range)
       "Compute the possible slots for the ticket-field-range. Return an array of T
        and NIL where an index has value T that index is a possible slot for the ticket
        field."
         (loop for ticket in *valid-tickets*
            with memb-arr = (make-array (length *your-ticket*) :initial-element t)
            do (loop
                  for value in ticket
                  for i from 0
                  if (not (in-uoi value ticket-field-range))
                  do (setf (aref memb-arr i) nil))
            finally (return memb-arr)))

     (defun possible-slot-array ()
       "A column index j corresponds to a slot on the ticket; a row index i
       corresponds with a ticket field."
       (make-array '(20 20)
                   :initial-contents
                   (mapcar #'possible-slots (get-ticket-field-ranges))))

     (defun possible-slot-counts (arr)
       "Returns a list where each element corresponds to the number of ticket fields
       that could be valid in that slot."
       (loop for j from 0 below 20
          collect (loop for i from 0 below 20
                     counting (aref arr i j))))

     (defun get-row-for-slot-count (n exclude)
       "Retrieve the row of (POSSIBLE-SLOT-ARRAY) where (POSSIBLE-SLOT-COUNTS) is
       N. Use EXCLUDE to exclude the TICKET-FIELD-INDEX values returned for lower
       values of N."
       (let* ((arr (possible-slot-array))
              (pslot-counts (possible-slot-counts arr))
              (search-column (loop
                                for c in pslot-counts
                                for i from 0
                                until (eql c n)
                                finally (return i))))
         (car
          (loop for i from 0 below 20
             if (and (aref arr i search-column) (not (find i exclude)))
             collect (list :ticket-field-index i :slot-number search-column)))))

     (defun departure-slots ()
       "The departure ticket field indices are the first six. So we need the slot
       numbers corresponding to ticket-field-index 0 through 5."
       (loop for n from 1 to 20
          with exclude = nil
          for result = (get-row-for-slot-count n exclude)
          do (push (getf result :ticket-field-index) exclude)
          if (<= (getf result :ticket-field-index) 5)
          collect (getf result :slot-number)))

     (defun get-your-ticket-value-at (slot)
       (nth slot *your-ticket*))


     ;;;; final

     (defun day16-part1 ()
       (apply
        #'+
        (apply
         #'append
         (remove
          nil
          (mapcar
           #'(lambda (ticket)
               (remove-if
                #'(lambda (value)
                    (in-range value))
                ticket))
           ,*nearby-tickets*)))))

     (defun day16-part2 ()
       (apply #'* (mapcar #'get-your-ticket-value-at (departure-slots))))

     (verbose1
       (day16-part1)
       (day16-part2))
   #+end_src

   #+RESULTS:
   : (DAY16-PART1) : -> 25895
   : (DAY16-PART2) : -> 5865723727753

** Day 17
   :PROPERTIES:
   :ID:       630D7CAB-D991-4C25-B29E-413F5BE1E923
   :END:

   #+begin_src lisp :exports both :results output :tangle day17.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")
     (defparameter *day17* (read-file "d17.txt"))
     (defparameter *state* (make-hash-table :test 'equalp))

     (defun initialize (&optional (dim 3))
       (labels
           ((clear-state ()
              (loop for key being the hash-keys of *state*
                 do (remhash key *state*)))
            (cube-status (c)
              (cond ((char= c #\#) 1)
                    ((char= c #\.) 0)
                    (t nil)))
            (repeat (item times) (loop repeat times collect item))
            (indexer (dim &rest indices)
              (concatenate 'list indices (repeat 0 (- dim 2))))
            (parse-input ()
              (loop for line in *day17*
                 for i from 0
                 do (loop for c across line
                       for j from 0
                       do (setf (gethash (indexer dim i j) *state*)
                                (cube-status c))))))
         (clear-state)
         (parse-input)))

     (defun get-state (idx)
       (gethash idx *state*))

     (defun initialize-state (idx)
       (setf (gethash idx *state*) 0))

     (defun uninitialized-p (idx)
       (null (gethash idx *state*)))

     (defun active-p (idx)
       (eql 1 (gethash idx *state*)))

     (defun print-cubes ()
       (maphash #'(lambda (k v)
                  (format t "k: ")
                  (princ k)
                  (format t " v: ~a~%" v))
                ,*state*))

     (defun gensym-vector (len)
       "Create a vector of length LEN of generated symbols."
       (map 'vector #'(lambda (x) (gensym)) (loop for i from 0 below len collect i)))

     (defmacro get-state-bounds (&optional (state-var *state*) (dim 3))
       "Get min and max indices for *state*."
       (let ((bounds-vars (gensym-vector (* 2 dim))))
         `(loop for idx being the hash-keys of ,state-var
             using (hash-value state)
             if (not (null state))
               ,@(loop for d from 0 below dim
                    append
                      `(minimize (nth ,d idx) into ,(aref bounds-vars (* 2 d)))
                    append
                      `(maximize (nth ,d idx) into ,(aref bounds-vars (1+ (* 2 d)))))
             finally (return (values
                              ,@(loop for i from 0 below dim
                                   collect `(cons ,(aref bounds-vars (* 2 i))
                                                  ,(aref bounds-vars (1+ (* 2 i))))))))))

     (defun pprint-state ()
       "Only works with 3 dimensions right now."
       (multiple-value-bind (ib jb kb) (get-state-bounds)
         (loop for k from (car kb) to (cdr kb)
            collect (loop for i from (car ib) to (cdr ib)
                       collect (loop for j from (car jb) to (cdr jb)
                                  if (eql 1 (get-state (list i j k)))
                                  collect #\# into result
                                  else collect #\. into result
                                  finally (return (concatenate 'string result)))
                         into result
                       finally (return (format nil "~{~a~^~%~}~%" result)))
            into result
            finally (format t "~{~a~^~%~}~%" result))))

     (defmacro relative-neighbours (dim)
       "Compute all relative neighbours in dimension DIM."
       (let* ((indices (gensym-vector dim))
              (result `(for item = (list ,@(map 'list #'identity indices))
                            unless (every #'zerop item)
                            collect item)))
         (loop for d from 0 below dim
            if (= d 0)
            do (setf result `(loop for ,(aref indices (1- (- dim d)))
                                from -1 to 1 ,@result))
            else do (setf result
                          `(loop for ,(aref indices (1- (- dim d)))
                              from -1 to 1 append ,result))
            finally (return result))))

     (defparameter *relative-neighbours3* (relative-neighbours 3))
     (defparameter *relative-neighbours4* (relative-neighbours 4))

     (defun idx-adder (idx)
       "Return a function that adds IDX to its input."
       (lambda (x) (mapcar #'+ idx x)))

     (defun get-neighbours-of (idx)
       "Return a list of the neighbours of IDX."
       (cond ((= (length idx) 3) (mapcar (idx-adder idx) *relative-neighbours3*))
             ((= (length idx) 4) (mapcar (idx-adder idx) *relative-neighbours4*))
             (t (error "get-neighbours-of: idx should have length 3 or 4; 
     other dimensions not implemented."))))

     (defun uninitialized-neighbours-of (idx)
       "Return a list of the uninitialized neighbours "
       (remove-if-not #'uninitialized-p (get-neighbours-of idx)))

     (defun count-active-neighbours (idx)
       "Return a count of neighbours with state 1."
       (count-if #'active-p (get-neighbours-of idx)))

     (defun activation (idx)
       "Compute activation for cube at IDX."
       (when (uninitialized-p idx)
         (initialize-state idx))
       (let ((num-active-neighbours (count-active-neighbours idx)))
         (cond ((and (= (get-state idx) 1) (<= 2 num-active-neighbours 3)) 1)
               ((and (= (get-state idx) 0) (= num-active-neighbours 3)) 1)
               (t 0))))

     (defmacro initialize-frontier (&optional (dim 3))
       "Initialize the *STATE* elements along the boundary of the slice."
       (let* ((vars (gensym-vector dim))
              (bounds (gensym-vector dim))
              (result `(loop for ,(aref vars 0)
                          from (1- (car ,(aref bounds 0)))
                          to (1+ (cdr ,(aref bounds 0)))
                          do (loop for ,(aref vars 1)
                                from (1- (car ,(aref bounds 1)))
                                to (1+ (cdr ,(aref bounds 1)))
                                do (activation (list ,@(map 'list #'identity vars)))))))
         `(multiple-value-bind ,(map 'list 'identity bounds) (get-state-bounds *state* ,dim)
            ,(loop for d from 2 below dim
                do (setf result `(loop for ,(aref vars d)
                                    from (1- (car ,(aref bounds d)))
                                    to (1+ (cdr ,(aref bounds d)))
                                    do ,result))
                  finally (return result)))))

     (defun update-state ()
       "Update *STATE* with the next cycle's configuration."
       (multiple-value-bind (new-state uninit)
           (loop for idx being the hash-keys of *state*
              collect (cons idx (activation idx)) into new-state
              append (uninitialized-neighbours-of idx) into uninit
              finally (return (values new-state (remove-duplicates uninit :test 'equalp))))
         (loop for idx in uninit
            do (setf (gethash idx *state*) (activation idx)))
         (loop for item in new-state
            for idx = (car item)
            for state = (cdr item)
            do (setf (gethash idx *state*) state))))

     (defun count-active-cubes ()
       "Count the number of active cubes in *STATE*."
       (loop for idx being the hash-keys of *state*
          using (hash-value state)
          counting (= state 1)))

     (defun day17-part1 ()
       (initialize)
       (initialize-frontier)
       (loop repeat 6 do (update-state))
       (count-active-cubes))

     (defun day17-part2 ()
       (initialize 4)
       (initialize-frontier 4)
       (loop repeat 6 do (update-state))
       (count-active-cubes))

     (verbose1
       (day17-part1)
       (day17-part2))
   #+end_src

   #+RESULTS:
   : (DAY17-PART1) : -> 353
   : (DAY17-PART2) : -> 2472
   


** Day 18
   :PROPERTIES:
   :ID:       3E812F30-024A-4A5B-AB3D-DD0230E93E25
   :END:

   #+begin_src lisp :exports both :results output :tangle day18.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")
     (defparameter *day18* (read-file "d18.txt"))

     (defun parse-line (line)
       (let* ((characters
               (loop for c across line
                  if (and (char/= c #\Space) (digit-char-p c))
                  collect (parse-integer (string c))
                  else if (char/= c #\Space)
                  collect c)))
         characters))


     (defun plus-p (c)
       (and (characterp c) (char= #\+ c)))

     (defun times-p (c)
       (and (characterp c) (char= #\* c)))

     (defun operator-p (x)
       (and (characterp x) (or (char= #\+ x) (char= #\* x))))

     (defun paren-p (x)
       (and (characterp x) (or (char= #\( x) (char= #\) x))))

     (defun open-paren-p (x)
       (and (characterp x) (char= #\( x)))

     (defun close-paren-p (x)
       (and (characterp x) (char= #\) x)))

     (defun get-operator (c)
       (when (operator-p c)
         (cond ((plus-p c) #'+)
               ((times-p c) #'*)
               (t nil))))

     (defun compute-line (expr)
       "Compute EXPR with first-come-first-served operator precedence."
       (loop for tail on expr for x in expr
          with paren-level = 0
          with digit-stack = nil
          with oper-stack = nil
          while (>= paren-level 0)
          ;; If #\(, compute the inner expression and add it to the digit-stack
          if (and (zerop paren-level) (open-paren-p x))
          do (progn
               (push (compute-line (cdr tail)) digit-stack)
               (incf paren-level))
          ;; Ignore nested #\(
          else if (open-paren-p x)
          do (incf paren-level)
          ;; Detect unnesting
          else if (close-paren-p x)
          do (decf paren-level)
          ;; Add numbers to the digit stack
          else if (and (zerop paren-level) (numberp x))
          do (push x digit-stack)
          ;; Add operators to the operator stack
          else if (and (zerop paren-level) (operator-p x))
          do (push x oper-stack)
          ;; Compute when possible - first come first served!
          if (and (= 2 (length digit-stack)) oper-stack)
          do (progn
               (let* ((a (pop digit-stack))
                      (b (pop digit-stack))
                      (oper-char (pop oper-stack))
                      (result (funcall (get-operator oper-char) a b)))
                 (push result digit-stack)))
          ;; the final item on the digit stack is the final answer
          finally (return (pop digit-stack))))

     (defun compute-line2 (expr)
       "Compute EXPR with addition-first operator precedence."
       (loop for tail on expr for x in expr
          with paren-level = 0
          with digit-stack = nil
          with oper-stack = nil
          while (>= paren-level 0)
          ;; If #\(, compute the inner expression and add it to the digit-stack
          if (and (zerop paren-level) (open-paren-p x))
          do (progn
               (push (compute-line2 (cdr tail)) digit-stack)
               (incf paren-level))
          ;; Ignore nested #\(
          else if (open-paren-p x)
          do (incf paren-level)
          ;; Detect unnesting
          else if (close-paren-p x)
          do (decf paren-level)
          ;; Add numbers to the digit stack
          else if (and (zerop paren-level) (numberp x))
          do (push x digit-stack)
          ;; Add operators to the operator stack
          else if (and (zerop paren-level) (operator-p x))
          do (push x oper-stack)
          ;; If we just added a number to the digit-stack and there's a + on the
          ;; oper-stack, then we're all set for adding.
          if (and (or (numberp x) (close-paren-p x))
                  (>= (length digit-stack) 2)
                  (plus-p (car oper-stack)))
          do (let* ((a (pop digit-stack))
                    (b (pop digit-stack)))
               (pop oper-stack) ;; remove the #\+
               (push (funcall #'+ a b) digit-stack))
          ;; We did all the additions, so only multiplications remain;
          ;; return the product of the digit-stack.
          finally (return (apply #'* digit-stack))))

     (defun report-result (val string ans)
       (let ((result (= val ans)))
         (format t "~:[FAIL~;pass~]: ~a -> ~a ~:[/=~;==~] ~a~%" result string val result ans)
         result))

     (defmacro check-func (func &body string-ans-pairs)
       `(progn ,@(loop for (string ans) on string-ans-pairs
                    if (and (stringp string))
                    collect `(report-result
                              (funcall ,func (parse-line ,string))
                              ,string ,ans))))

     (check-func #'compute-line
       "2 * 3 + (4 * 5)" 26
       "5 + (8 * 3 + 9 + 3 * 4 * 3)" 437
       "5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4))" 12240
       "((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2" 13632)

     (check-func #'compute-line2
       "1 + (2 * 3) + (4 * (5 + 6))" 51
       "2 * 3 + (4 * 5)" 46
       "5 + (8 * 3 + 9 + 3 * 4 * 3)" 1445
       "5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4))" 669060
       "((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2" 23340)

     (defun main (&optional (func #'compute-line))
       (apply #'+ (loop for line in *day18* collect (funcall func (parse-line line)))))

     (defun day18-part1 ()
       (main))

     (defun day18-part2 ()
       (main #'compute-line2))

     (verbose1
       (day18-part1)
       (day18-part2))
   #+end_src

   #+RESULTS:
   #+begin_example
   pass: 2 * 3 + (4 * 5) -> 26 == 26
   pass: 5 + (8 * 3 + 9 + 3 * 4 * 3) -> 437 == 437
   pass: 5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4)) -> 12240 == 12240
   pass: ((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2 -> 13632 == 13632
   pass: 1 + (2 * 3) + (4 * (5 + 6)) -> 51 == 51
   pass: 2 * 3 + (4 * 5) -> 46 == 46
   pass: 5 + (8 * 3 + 9 + 3 * 4 * 3) -> 1445 == 1445
   pass: 5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4)) -> 669060 == 669060
   pass: ((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2 -> 23340 == 23340
   (DAY18-PART1) : -> 280014646144
   (DAY18-PART2) : -> 9966990988262
   #+end_example
   
One attempt each.

** Day 19
   :PROPERTIES:
   :ID:       30E79D0C-85B1-41C9-ADC3-94ACFFA557A6
   :END:

   I probably need to check out [[https://github.com/Andrew-William-Smith/advent-of-code/blob/master/day19.lisp][Andrew Smith's solution]], but I'd really like to
   take /one/ more stab at it before throwing in the towel.

   #+begin_src lisp :exports both :results output :tangle day19.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")
     (load "~/.sbclrc")
     (ql:quickload "split-sequence")

     (defparameter *day19* (read-file "d19.txt"))

     (defun zero-length-p (sequence)
       (zerop (length sequence)))

     (defun str-base-rule-p (rule-text)
       (some #'(lambda (x) (find x rule-text)) (list #\a #\b)))

     (defun base-rule-p (rule)
       (when (and (characterp (cdr rule))
                  (or (char= (cdr rule) #\a)
                      (char= (cdr rule) #\b)))
         (cdr rule)))

     (defun str-disjunction-p (rule-text)
       (find #\| rule-text))

     (defun parse-input ()
       (labels ((load-data ()
                  (destructuring-bind (rules messages)
                      (split-sequence:split-sequence-if
                       #'zero-length-p
                       (read-file "d19.txt"))
                    (values rules messages)))
                (parse-rule-text (rule-text)
                  (cond ((str-base-rule-p rule-text) (str-base-rule-p rule-text))
                        ((str-disjunction-p rule-text)
                         (mapcar #'(lambda (x) (if (string= x "|") #\| (parse-integer x)))
                                 (remove-if
                                  #'zero-length-p
                                  (split-sequence:split-sequence-if
                                   #'(lambda (x) (char= x #\Space))
                                   rule-text))))
                        (t (mapcar #'parse-integer
                                   (split-sequence:split-sequence #\Space rule-text)))))
                (parse-rule (rule-line)
                  (destructuring-bind (rule-name rule-text)
                      (split-sequence:split-sequence #\: rule-line)
                    (cons (parse-integer rule-name) (parse-rule-text (subseq rule-text 1))))))
         (multiple-value-bind (rules messages) (load-data)
           (values (mapcar #'parse-rule rules) messages))))

     (multiple-value-bind (rules messages) (parse-input)
       (defparameter *rules* rules)
       (defparameter *messages* messages))

     ,*rules*

     (defun first-two (list)
       (when (listp list)
         (list (car list) (cadr list))))

     (defun last-two (list)
       (when (listp list)
         (let ((rev (reverse list)))
           (list (cadr rev) (car rev)))))

     (defun build-tree (rule-number)
       (let* ((rule (assoc rule-number *rules*))
              (rule-body (cdr rule)))
         (cond ((base-rule-p rule) (base-rule-p rule))
               (t
                (loop for number in rule-body
                   if (numberp number)
                   collect (build-tree number)
                   else collect #\|)))))

     (build-tree 0)

     ;;;; tree snippet
     ;; (#\b
     ;;      (#\a (((#\a #\| #\b) (#\a #\| #\b)) #\a #\| (#\b #\b #\| #\a #\a) #\b)
     ;;       #\| #\b (#\a (#\b #\a) #\| #\b (#\b #\b)))
     ;;      #\| #\a
     ;;      (#\a
     ;;       ((#\a #\a #\| #\b (#\a #\| #\b)) #\b #\|
     ;;        ((#\a #\| #\b) #\b #\| #\a #\a) #\a)
     ;;       #\| #\b
     ;;       (((#\a #\| #\b) (#\a #\| #\b)) #\a #\| (#\b #\b #\| #\a #\a) #\b)))

     ;; 0: 4 1 5
     ;; 1: 2 3 | 3 2
     ;; 2: 4 4 | 5 5
     ;; 3: 4 5 | 5 4
     ;; 4: "a"
     ;; 5: "b"
     ;; 
     ;;                     0
     ;;     4               1               5
     ;;     a     2     3   |   3     2     b
     ;;         44|55 45|54   45|54 44|55
     ;;         aa|bb ab|ba   ab|ba aa|bb
     ;; ababbb
     ;; bababa
     ;; abbbab
     ;; aaabbb
     ;; aaaabbb



     (defun day19-part1 ()
       nil)

     (defun day19-part2 ()
       nil)

     (verbose1
       (day19-part1)
       (day19-part2))
   #+end_src
   

** Day 20
   :PROPERTIES:
   :ID:       DA33F1D0-C329-489B-8D82-DA8816AF6330
   :END:

   #+begin_src lisp :exports both :results output :tangle day20.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")
     (load "~/.sbclrc")
     (ql:quickload "split-sequence")

     (defun parse-input ()
       (labels ((load-data () (read-file "d20.txt"))
                (split-tiles ()
                  (split-sequence:split-sequence-if
                   #'(lambda (line)
                       (zerop (length line)))
                   (load-data)))
                (parse-tile-name (line)
                  (parse-integer (remove-if-not #'digit-char-p line)))
                (create-tile-array (lines)
                  (make-array '(10 10) :initial-contents lines))
                (parse-tile (lines)
                  (values (parse-tile-name (car lines))
                          (create-tile-array (cdr lines))))
                (hash-tile (tbl tile-lines)
                  (when tile-lines
                    (multiple-value-bind (tile-name tile-arr) (parse-tile tile-lines) 
                      (setf (gethash tile-name tbl) tile-arr)
                      tile-name)))
                (main ()
                  (loop for tile-lines in (split-tiles)
                     with tbl = (make-hash-table)
                     with keys = nil
                     if tile-lines
                     do (push (hash-tile tbl tile-lines) keys)
                     finally (return (values tbl keys)))))
         (main)))

     (multiple-value-bind (tbl tile-keys) (parse-input)
       (defparameter *tbl* tbl)
       (defparameter *tile-keys* tile-keys))


     (defun count-hashes-nesw (tile-name)
       (let* ((tile (gethash tile-name *tbl*))
              (east-west (loop for i from 0 to 9
                            counting (char= (aref tile i 0) #\#) into west
                            counting (char= (aref tile i 9) #\#) into east
                            finally (return (cons east west))))
              (north-south (loop for j from 0 to 9
                              counting (char= (aref tile 0 j) #\#) into north
                              counting (char= (aref tile 9 j) #\#) into south
                              finally (return (cons north south)))))
         (list (car north-south) (car east-west)
               (cdr north-south) (cdr east-west))))

     (defun edges-match-p (edge1 edge2)
       (loop for c1 in edge1
          for c2 in edge2
          if (char/= c1 c2)
          do (return-from edges-match-p nil)
          finally (return t)))

     (defun get-edge (tile-name side &optional (rev nil))
       (labels ((get-n-edge (tile)
                  (loop for j from 0 to 9
                  collect (aref tile 0 j)))
                (get-e-edge (tile)
                  (loop for i from 0 to 9
                     collect (aref tile i 9)))
                (get-s-edge (tile)
                  (loop for j from 0 to 9
                     collect (aref tile 9 j)))
                (get-w-edge (tile)
                  (loop for i from 0 to 9
                       collect (aref tile i 0)))
                (get-edge-from (tile)
                  (cond ((eq side :n) (get-n-edge tile))
                        ((eq side :e) (get-e-edge tile))
                        ((eq side :s) (get-s-edge tile))
                        ((eq side :w) (get-w-edge tile))))
                (reverse-maybe (edge) (if rev (reverse edge) edge)))
         (reverse-maybe (get-edge-from (gethash tile-name *tbl*)))))

     ;;;; If you're an edge tile you only match with two other tiles. Moreover, you
     ;;;; should only be able to match on one side if the problem is set up in the
     ;;;; easiest way. Let's proceed and hope for the best.

     (defun test-tile-fit (tile-name1 tile-name2)
       (let ((directions (list :n :e :s :w)))
         (loop for d1 in directions
            for edge1 = (get-edge tile-name1 d1)
            do (loop for d2 in directions
                  for edge2 = (get-edge tile-name2 d2)
                  if (edges-match-p edge1 edge2)
                  do (return-from test-tile-fit (list d1 d2 nil))
                  if (edges-match-p (reverse edge1) edge2)
                  do (return-from test-tile-fit (list d1 d2 :rev))))))

     (defun e-match-p (tile-name1 tile-name2)
       (let ((directions (list :n :e :s :w))
             (edge1 (get-edge tile-name1 :e)))
         (loop for d in directions
            for edge2 = (get-edge tile-name2 d)
            if (edges-match-p edge1 edge2)
            do (return-from e-match-p (list tile-name2 d nil))
            if (edges-match-p edge1 (reverse edge2))
            do (return-from e-match-p (list tile-name2 d :rev)))))

     (defun s-match-p (tile-name1 tile-name2)
       (let ((directions (list :n :e :s :w))
             (edge1 (get-edge tile-name1 :s)))
         (loop for d in directions
            for edge2 = (get-edge tile-name2 d)
            if (edges-match-p edge1 edge2)
            do (return-from s-match-p (list tile-name2 d nil))
            if (edges-match-p edge1 (reverse edge2))
            do (return-from s-match-p (list tile-name2 d :rev)))))

     (defun brute-tile-fits ()
       (loop for key1 in *tile-keys*
        for key-tail on *tile-keys*
        append (loop for key2 in (cdr key-tail)
                  for result = (test-tile-fit key1 key2)
                  if result 
                  collect (list (cons key1 key2) result))))

     (defun brute-tile-fits-with-dups ()
       (loop for key1 in *tile-keys*
          append (loop for key2 in *tile-keys*
                  for result = (test-tile-fit key1 key2)
                  if (and  result (/= key1 key2))
                  collect (list (cons key1 key2) result))))

     (defparameter *tile-matches* (brute-tile-fits))
     (defparameter *tile-matches-dup* (brute-tile-fits-with-dups))

     (defun in-cons-cell (tile-name)
       #'(lambda (x) (or (= (caar x) tile-name)
                         (= (cdar x) tile-name))))

     (defun get-matches-for (tile-name)
       (remove-if-not (in-cons-cell tile-name) *tile-matches*))

     (defun get-matches-for-dup (tile-name)
       (remove-if-not #'(lambda (x) (= (caar x) tile-name)) *tile-matches-dup*))

     (defun find-corners ()
       (loop for tile-name in *tile-keys*
          if (= (length (get-matches-for tile-name)) 2)
          collect tile-name))


     ;;;; Part 2

     (defun dotted-pair-p (item)
       (and (listp item) (not (listp (cdr item)))))

     (defun cons-pair (dotted-pair tile-name)
       (when (and (dotted-pair-p dotted-pair) (numberp tile-name))
         (cond ((= (car dotted-pair) tile-name) (cdr dotted-pair))
               ((= (cdr dotted-pair) tile-name) (car dotted-pair))
               (t nil))))

     (defun get-tile-names-matching (tile-name)
       (let* ((match-pairs
               (mapcar #'car (get-matches-for tile-name))))
         (mapcar #'(lambda (dotted-pair) (cons-pair dotted-pair tile-name)) match-pairs)))

     (defun find-mutual-matches (tile-name1 tile-name2)
       (let ((matches1 (get-tile-names-matching tile-name1))
             (matches2 (get-tile-names-matching tile-name2)))
         (intersection matches1 matches2)))

     (defun flip-about-y-axis (the-array)
       "Flip THE-ARRAY about the y-axis."
       (destructuring-bind (m n &rest rest) (array-dimensions the-array)
         (when rest (error "rotate-90: 2D array required."))
         (make-array
          (list m n)
          :initial-contents
          (loop for i from 0 below m
             collect (loop for j from 0 below n
                        collect (aref the-array i (- (1- n) j)))))))

     (defun flip-about-x-axis (the-array)
       "Flip THE-ARRAY about the x-axis."
       (destructuring-bind (m n &rest rest) (array-dimensions the-array)
         (when rest (error "rotate-90: 2D array required."))
         (make-array
          (list m n)
          :initial-contents
          (loop for i from 0 below m
             collect (loop for j from 0 below n
                        collect (aref the-array (- (1- m) i) j))))))

     (defun rotate-90 (the-array)
       "Rotate a 2D array clockwise 90 degrees."
       (destructuring-bind (m n &rest rest) (array-dimensions the-array)
         (when rest (error "rotate-90: 2D array required."))
         (make-array
          (list m n)
          :initial-contents
          (loop for i from 0 below m
             collect (loop for j from 0 below n
                        collect (aref the-array (- (1- n) j) i))))))

     (defun rotation-amount (dir1 dir2)
       "Return amount of clock-wise 90 degree rotations to perform on tile
       corresponding to DIR1. (DIR2 is the direction of the reference tile.) 
       DIR1 = current DIR2; = desired."
       (let* ((rot '((:n . 0) (:e . 1) (:s . 2) (:w . 3)))
             (s1 (cdr (assoc dir1 rot)))
             (s2 (cdr (assoc dir2 rot))))
         (mod (- s2 s1) 4)))

     (defun rotator (arg times)
       (if (= times 0) arg (rotator (rotate-90 arg) (1- times))))

     (defun arrange-helper (i j seen arr)
       (unless (and (= i 0) (= j 0))
         (let* ((i-nbr (if (= j 0) (1- i) i))
                (j-nbr (if (= j 0) j (1- j)))
                (tile-name (aref arr i-nbr j-nbr))
                (neighbours (remove-if #'(lambda (x) (find x seen))
                                       (get-tile-names-matching tile-name)))
                (match-p (if (= j 0) #'s-match-p #'e-match-p))
                (flip-func (if (= j 0) #'flip-about-y-axis #'flip-about-x-axis))
                (match-dir (if (= j 0) :n :w))
                (match-info
                 (car (remove
                       nil
                       (mapcar #'(lambda (nbr) (funcall match-p tile-name nbr)) neighbours)))))
           (format t "~a: ~a ~a ... ~a~%" tile-name neighbours match-info match-p)
           (destructuring-bind (match-name dir rev) match-info
             (labels ((my-rotator (arg) (rotator arg (rotation-amount dir match-dir))))
               (push match-name seen)
               (setf (aref arr i j) match-name)
               (setf (gethash match-name *tbl*)
                     (my-rotator (gethash match-name *tbl*)))
               (when rev
                 (setf (gethash match-name *tbl*)
                       (funcall flip-func (gethash match-name *tbl*))))
               match-name)))))

     (defun arrange-tiles ()
       (let* ((arr (make-array '(12 12) :initial-element nil))
              (seen nil))
         (setf (aref arr 0 0) 1873)
         (push 1873 seen)
         (loop for i from 0 below 12
            do (loop for j from 0 below 12
                  do (let ((match-name  (arrange-helper i j seen arr)))
                       (when match-name
                         (push match-name seen)
                         (setf (aref arr i j) match-name)))))
         arr))

     (defun make-full-image-array ()
       (let* ((square-width (- 10 2))
              (num-squares-per-side 12)
              (im-width (* square-width num-squares-per-side))
              (result (make-array (list im-width im-width) :initial-element #\.))
              (arrangement (arrange-tiles)))
         (loop for i0 from 0 below num-squares-per-side
            do (loop for j0 from 0 below num-squares-per-side
                  do (let* ((square-name (aref arrangement i0 j0))
                            (square (gethash square-name *tbl*)))
                       (loop for i1 from 1 to square-width
                          do (loop for j1 from 1 to square-width
                                if (char= (aref square i1 j1) #\#)
                                do (setf (aref result
                                               (+ (* i0 square-width) (1- i1))
                                               (+ (* j0 square-width) (1- j1)))
                                         #\#))))))
         result))

     (defparameter *final-image* (make-full-image-array))

     (let ((sea-monster (list
                         "                  # "
                         "#    ##    ##    ###"
                         " #  #  #  #  #  #   ")))
       (defparameter *sea-monster*
         (make-array '(3 20)
                     :initial-contents
                     (loop for line in sea-monster
                        collect (loop for c across line
                                   if (char= c #\#)
                                   collect #\#
                                   else collect nil)))))

     (defun check-for-sea-monster-at (i0 j0)
       (loop for di from 0 below 3
          do (loop for dj from 0 below 20
                do (let ((image-char (aref *final-image* (+ i0 di) (+ j0 dj)))
                         (sm-char (aref *sea-monster* di dj)))
                     (when (and sm-char (char= sm-char #\#))
                       (when (char/= sm-char image-char)
                         (return-from check-for-sea-monster-at nil))))))
       t)

     (defun count-sea-monsters ()
       (destructuring-bind (m n) (array-dimensions *final-image*)
         (loop for i from 0 below (- m 3)
            summing (loop for j from 0 below (- n 20)
                       counting (check-for-sea-monster-at i j)))))

     (defun find-final-image-orientation ()
       (let ((result nil))
         (loop for r from 0 to 4
            do (setf result (count-sea-monsters))
            if (and result (> result 0))
            do (return-from find-final-image-orientation result)
            else
            do (setf *final-image* (rotate-90 *final-image*)))
         (setf *final-image* (flip-about-y-axis *final-image*))
         (loop for r from 0 to 4
            do (setf result (count-sea-monsters))
            if (and result (> result 0))
            do (return-from find-final-image-orientation result)
            else
            do (setf *final-image* (rotate-90 *final-image*)))))

     (defun mark-sea-monsters ()
       (destructuring-bind (m n) (array-dimensions *final-image*)
         (let ((arr *final-image*))
           (loop for i from 0 below (- m 3)
              do (loop for j from 0 below (- n 20)
                    if (check-for-sea-monster-at i j)
                    do (loop for di from 0 below 3
                          do (loop for dj from 0 below 20
                                do (let ((image-char (aref *final-image* (+ i di) (+ j dj)))
                                         (sm-char (aref *sea-monster* di dj)))
                                     (when (and sm-char (char= sm-char #\#))
                                       (setf (aref arr (+ i di) (+ j dj)) #\*)))))))
           arr)))


     ;;;; Final


     (defun day20-part1 ()
       (apply #'* (find-corners)))

     (defun day20-part2 ()
       (let ((labelled-image (mark-sea-monsters)))
         (loop for i from 0 below 96
            summing (loop for j from 0 below 96
                       counting (char= #\# (aref labelled-image i j))))))

     (verbose1
       (day20-part1)
       (day20-part2))
   #+end_src

   I introduced a bug related to the ~:rev~ / ~nil~ stuff. When I originally
   constructed ~*tile-matches*~ I used one convention, but when building the
   arrangement, I used a different convention. I've gotten two stars for it and
   I'm too lazy to go back to sort things out.


** Day 21
   :PROPERTIES:
   :ID:       D91E6628-0E1F-4814-A868-2959148E2326
   :END:

   #+begin_src lisp :exports both :results output :tangle day21.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")
     (load "~/.sbclrc")
     (ql:quickload "split-sequence")

     (defun parse-input ()
       (labels ((load-data () (read-file "d21.txt"))
                (parse-ingredients (ingredients)
                  (remove-if #'(lambda (x) (zerop (length x)))
                             (split-sequence:split-sequence #\Space ingredients)))
                (parse-allergens (allergens)
                  (mapcar #'(lambda (x) (if (or (find #\) x) (find #\, x))
                                            (subseq x 0 (1- (length x))) x))
                          (subseq (split-sequence:split-sequence #\Space allergens) 1)))
                (parse-line (line)
                  (destructuring-bind (ingredients allergens) (split-sequence:split-sequence #\( line)
                    (list (parse-ingredients ingredients) (parse-allergens allergens))))
                (main ()
                  (loop for line in (mapcar #'parse-line (load-data))
                     with ingredients = nil
                     with allergens = nil
                     do (push (pop line) ingredients)
                     do (push (pop line) allergens)
                     finally (return (values ingredients allergens)))))
         (multiple-value-bind (ingredients allergens) (main)
           (defparameter *ingredients* ingredients)
           (defparameter *allergens* allergens)
           (defparameter *unique-ingredients* (remove-duplicates (apply #'append ingredients)
                                                                 :test #'string=))
           (defparameter *unique-allergens* (remove-duplicates (apply #'append allergens)
                                                               :test #'string=)))))

     (parse-input)

     (defun build-hash ()
       (let ((h (make-hash-table :test #'equal)))
         (loop for allergen in *unique-allergens*
            do (loop for ingredient in *unique-ingredients*
                  do (setf (gethash (cons ingredient allergen) h) t)
                  do (loop named inner
                        for ingredients in *ingredients*
                        for allergens in *allergens*
                        if (and (find allergen allergens :test #'equal)
                                (not (find ingredient ingredients :test #'equal)))
                        do (progn (setf (gethash (cons ingredient allergen) h) nil)
                                  (return-from inner))))
              )
         h))

     (defun allergen-free-ingredients ()
       (loop with h = (build-hash)
          for ingredient in *unique-ingredients*
          for slice = (loop for allergen in *unique-allergens*
                         collect (gethash (cons ingredient allergen) h))
          if (every #'null slice)
          collect ingredient))


     (defun day21-part1 ()
       "Count the number of times an allergen-free ingredient is used."
       (loop for ingredients in *ingredients*
        with allergen-free-ingredients = (allergen-free-ingredients)
        summing (loop for ingredient in ingredients
                   counting (find ingredient allergen-free-ingredients
                                  :test #'equal))))

     (defun allergenic-ingredients ()
       "Create a copy of *ingredients* with inert ingredients removed."
       (let ((inert (allergen-free-ingredients)))
         (mapcar #'(lambda (line)
                     (remove-if #'(lambda (x) (find x inert :test #'equal)) line))
                 ,*ingredients*)))

     (defun get-possible-allergen-assignments ()
       (let* ((h (make-hash-table :test #'equal))
              (allergenic-ingredients (allergenic-ingredients))
              (unique-allergenic-ingredients (remove-duplicates
                                              (apply #'append allergenic-ingredients)
                                              :test #'equal)))
         (loop for allergen in *unique-allergens*
            do (loop for ingredient in unique-allergenic-ingredients
                  do (setf (gethash (cons ingredient allergen) h) t)
                  do (loop for allergens in *allergens*
                        for ingredients in allergenic-ingredients
                        if (and (find allergen allergens :test #'equal)
                                (not (find ingredient ingredients :test #'equal)))
                        do (setf (gethash (cons ingredient allergen) h) nil))))
         (loop for allergen in *unique-allergens*
            collect (loop for ingredient in unique-allergenic-ingredients
                       if (gethash (cons ingredient allergen) h)
                       collect ingredient))))

     (defun get-allergen-assignments ()
       (let ((assigned nil)
             (possible-allergen-assignments (get-possible-allergen-assignments)))
         (loop while (some #'(lambda (x) (> (length x) 1)) possible-allergen-assignments)
            do (setf possible-allergen-assignments
                     (loop for items in possible-allergen-assignments
                        for allergen in *unique-allergens*
                        if (= (length items) 1)
                        do (when (not (find (car items) assigned :test #'equal))
                             (push (car items) assigned))
                        and collect items
                        else collect (remove-if #'(lambda (x)
                                                    (find x assigned :test #'equal))
                                                items)))
            finally (return (sort
                             (pairlis *unique-allergens* (mapcar #'car possible-allergen-assignments))
                             #'string< :key #'car)))))


     (defun day21-part2 ()
       (let ((allergen-assignments (get-allergen-assignments)))
         (format nil "~{~a~^,~}" (mapcar #'cdr allergen-assignments))))

     (verbose1
       (day21-part1)
       (day21-part2))
   #+end_src
   



** Day 22
   :PROPERTIES:
   :ID:       7813A64E-B160-4518-B1CC-1BFF0CD9B627
   :END:


   #+begin_src lisp :exports both :results output :tangle day22.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")
     (load "~/.sbclrc")
     (ql:quickload "split-sequence")

     (defparameter *deck1* nil)
     (defparameter *deck2* nil)

     (defun parse-input ()
       (labels ((load-data () (read-file "d22.txt"))
                (parse-deck (deck)
                  (mapcar #'parse-integer (subseq deck 1)))
                (split-players ()
                  (let ((decks
                         (split-sequence:split-sequence-if
                          #'(lambda (x) (zerop (length x)))
                          (load-data))))
                    (mapcar #'parse-deck decks)))
                (main ()
                  (destructuring-bind (deck1 deck2) (split-players)
                    (defparameter *deck1* deck1)
                    (defparameter *deck2* deck2))))
         (main)))

     (defun play-round ()
       (when (and *deck1* *deck2*)
         (let ((card1 (pop *deck1*))
               (card2 (pop *deck2*)))
           (cond ((> card1 card2) (setf *deck1* (append *deck1* (list card1 card2))))
                 ((> card2 card1) (setf *deck2* (append *deck2* (list card2 card1))))
                 (t (error "The cards should never be equal."))))
         t))


     ;;;; part 2

     (defun record-round (deck1 deck2)
       "Return T if round was already in record; if not this function has the side
       effect of creating a record. Key is DECK1, value is DECK2."
       (cond ((gethash (list deck1 deck2) *game-record*) t)
             (t (setf (gethash (list deck1 deck2) *game-record*) :seen)
                nil)))

     (defun deck-subset (deck card)
       (assert (>= (length deck) card))
       (loop for i from 0 below card
          for x in deck collect x))

     (defun auto-win-p (arg)
       (eql arg :player-one-wins))

     (defun play-recursive-round (deck1 deck2 &optional (game-number 1) (round-number 1))
       (when (record-round deck1 deck2)
         (return-from play-recursive-round (list :player-one-wins nil)))
       (when (and deck1 deck2)
         (let ((card1 (pop deck1))
               (card2 (pop deck2))
               (num-remaining1 (length deck1))
               (num-remaining2 (length deck2)))
           (if (and (>= num-remaining1 card1)
                    (>= num-remaining2 card2))
               (let ((subgame-result
                      (play-recursive-combat (deck-subset deck1 card1)
                                             (deck-subset deck2 card2)
                                             (incf game-number) 0)))
                 (cond ((eql (car subgame-result) :player-one-wins)
                        (list (append deck1 (list card1 card2)) deck2))
                       ((eql (car subgame-result) :player-two-wins)
                        (list deck1 (append deck2 (list card2 card1))))
                       (t (error "not implemented."))))
               (cond ((> card1 card2)
                      (list (append deck1 (list card1 card2)) deck2))
                     ((> card2 card1)
                      (list deck1 (append deck2 (list card2 card1))))
                     (t (error "The cards should never be equal.")))))))


     (defun play-recursive-combat (deck1 deck2 &optional (game-number 1) (starting-round-number 0))
       (let ((*game-record* (make-hash-table :test #'equal)))
         (loop while (and deck1 deck2)
            do (destructuring-bind (new-deck1 new-deck2)
                   (play-recursive-round deck1 deck2 game-number (incf starting-round-number))
                 (when (auto-win-p new-deck1)
                   (return-from play-recursive-combat (list new-deck1 deck1 deck2)))
                 (setf deck1 new-deck1)
                 (setf deck2 new-deck2))
            finally (return (list (if deck1
                                      :player-one-wins
                                      :player-two-wins)
                                  deck1 deck2)))))

     ;;;; final

     (defun day22-part1 ()
       (parse-input)
       (loop while (play-round))
       (let ((deck (if *deck1* *deck1* *deck2*)))
         (loop for card in deck
            for counter from (length deck) downto 0
            summing (* card counter))))

     (defun day22-part2 ()
       (defparameter *game-record* (make-hash-table :test #'equal))
       (parse-input)
       (let* ((result (play-recursive-combat *deck1* *deck2*))
              (deck (if (eql (car result) :player-one-wins) (cadr result) (caddr result))))
         (loop for card in deck
            for counter from (length deck) downto 0
            summing (* card counter))))

     (verbose1
       (day22-part1)
       (day22-part2))
   #+end_src


   Creating a local binding of ~*game-record*~ was integral to getting everything
   to work; each copy of ~play-recursive-combat~ required a fresh hash-table. Btw
   I'm not sure if a hash table is the write structure to use. We probably could
   have gotten away with a list, but I thought the sizes might be large and
   benefit from a sublinear look-up time. 


** Day 23
   :PROPERTIES:
   :ID:       0C6A49D1-73DF-44A8-9826-6E7B69DC4045
   :END:

   #+begin_src lisp :exports both :results output :tangle day23.lisp :shebang "#!/usr/bin/env sbcl --script"
     ;;;; Parts 1 and 2
     (load "my-utils.lisp")
     (defparameter *cups* nil)

     (defun initial-data (&optional debug)
       (if debug
           (list 3 8 9 1 2 5 4 6 7)
           (list 6 1 4 7 5 2 8 3 9)))

     (defun make-cup-array (num-cups &optional debug)
       "Create an array where each index is a cup and each element is the next cup."
       (setf *cups* (make-array (1+ num-cups)))
       (let ((initial-data (initial-data debug))
             (remaining-data (loop for i from 9 below num-cups collect (1+ i))))
         (loop with cups = (append initial-data remaining-data)
            for cup in cups
            for next-cup in (cdr cups)
            do (setf (aref *cups* cup) next-cup)
            finally (setf (aref *cups* (car (last cups))) (car cups))))
       ,*cups*)

     (defun get-pick-up (current-cup)
       (loop for i from 0 below 3
          with idx = current-cup
          for cup = (aref *cups* idx) 
          collect cup
          do (setf idx cup)))

     (defun get-destination (current-cup num-cups pick-up)
       (let ((destination (1- current-cup)))
         (loop if (< destination 1)
            do (setf destination num-cups)
            until (not (find destination pick-up))
            do (decf destination)
            finally (return destination))))

     (defun move (current-cup)
       (let* ((pick-up (get-pick-up current-cup))
              (next-cup-idx (nth 2 pick-up))
              (next-cup (aref *cups* next-cup-idx))
              (num-cups (1- (array-dimension *cups* 0)))
              (destination (get-destination current-cup num-cups pick-up)))
         (setf (aref *cups* current-cup) next-cup)
         (setf (aref *cups* next-cup-idx) (aref *cups* destination))
         (setf (aref *cups* destination) (car pick-up))
         next-cup))

     (defun cup-code (cups idx)
       (loop with i = idx
          for cup = (aref cups i)
          until (= cup 1)
          collect cup into result
          do (setf i cup)
          finally (return (parse-integer (format nil "~{~a~}" result)))))

     (defun crab-product (cups idx)
       (let* ((cup1 (aref cups idx))
              (cup2 (aref cups cup1)))
         (* cup1 cup2)))

     (defun play-game (num-cups num-rounds &optional answer-type debug)
       (make-cup-array num-cups debug)
       (loop for i from 0 below num-rounds
          with current-cup = (car (initial-data debug))
          do (setf current-cup (move current-cup))
          finally (return (if (eql answer-type :cup-code)
                              (cup-code *cups* 1)
                              (crab-product *cups* 1)))))

     ;;;; final

     (defun day23-part1 ()
       (play-game 9 100 :cup-code))

     (defun day23-part2 ()
       (play-game (floor 1e6) (floor 1e7)))

     (verbose1
       (day23-part1)
       (day23-part2))
   #+end_src

   #+RESULTS:
   : (DAY23-PART1) : -> 89372645
   : (DAY23-PART2) : -> 21273394210
   

   I wound up using a hint from someone on the Reddit solutions /megathread/. I
   forgot the trick of being able to use a vector as a linked list. I think most
   of the computational effort for this problem may in fact come from some
   simply instantiating the initial length 1e6 vector. The rest is 3e7 very fast
   ~setf~-ing.

** Day 24
   :PROPERTIES:
   :ID:       46D0E21B-F87B-4E80-B83A-809688ACF9E1
   :END:


   #+begin_src lisp :exports both :results output :tangle day24.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")

     ;;;; part 1

     (defun fname (debug)
       (if debug "d24.test" "d24.txt"))

     (defun direction-names ()
       (list :east
             :north-east
             :north-west
             :west
             :south-west
             :south-east))

     (defun get-adjusted-vector (direction)
       "Return a vector for a neighbouring hexagon along DIRECTION in adjusted
        coordinates (i.e. y coord is scaled by 1/(sqrt 3))."
       (cond ((eql direction :east) (cons 1 0))
             ((eql direction :west) (cons -1 0))
             ((eql direction :north-east) (cons 1/2 1/2))
             ((eql direction :north-west) (cons -1/2 1/2))
             ((eql direction :south-west) (cons -1/2 -1/2))
             ((eql direction :south-east) (cons 1/2 -1/2))
             (t (error "direction not recognized: ~a" direction))))

     (defun parse-input (&optional debug)
       (labels ((load-data () (read-file (fname debug)))
                (parse-direction (char-list)
                  (cond ((and (find #\n char-list) (find #\e char-list)) :north-east)
                        ((and (find #\n char-list) (find #\w char-list)) :north-west)
                        ((and (find #\s char-list) (find #\e char-list)) :south-east)
                        ((and (find #\s char-list) (find #\w char-list)) :south-west)
                        ((find #\e char-list) :east)
                        ((find #\w char-list) :west)
                        (t (error "direction not recognized ~{~a~}" char-list))))
                (parse-line (line)
                  (loop with buffer = nil for c across line
                     do (push c buffer)
                     if (or (char= c #\e) (char= c #\w))
                     collect (parse-direction (nreverse buffer))
                     and do (setf buffer nil)))
                (main () (mapcar #'parse-line (load-data))))
         (main)))

     (defun cons+ (&rest vectors)
       (let ((cars (mapcar #'car vectors))
             (cdrs (mapcar #'cdr vectors)))
         (cons (apply #'+ cars) (apply #'+ cdrs))))

     (defun get-coords (directions)
       (apply #'cons+ (mapcar #'get-adjusted-vector directions)))

     (defun adjust-coord (coord &optional (tsfm #'/))
       (cons (car coord) (funcall tsfm (cdr coord) (sqrt 3))))

     (defun print-hash (hash)
       (loop for key being the hash-keys of hash using (hash-value val)
          do (format t "~a: ~a~%" key (mod val 2))))

     (defun count-black-tiles (hash)
       (loop for val being the hash-values of hash
          counting (and val (oddp val))))

     (defun get-neighbours (coord)
       "COORD should be an adjusted coord; returned neighbours are in adjusted format."
       (mapcar #'(lambda (vector) (cons+ coord vector))
               (mapcar #'get-adjusted-vector (direction-names))))

     (defun num-black-neighbours (coord hash)
       "COORD should be an adjusted coord."
       (let* ((neighbours (get-neighbours coord))
              (flips (mapcar #'(lambda (neighbour) (gethash neighbour hash)) neighbours)))
         (count-if #'(lambda (val) (and val (oddp val))) flips)))

     (defun num-white-neighbours (coord hash)
       (- 6 (num-black-neighbours coord hash)))

     (defun black-p (coord hash)
       (when (and coord hash)
         (let* ((val (gethash coord hash)))
           (and val (oddp val)))))

     (defun white-p (coord hash)
       (when (and coord hash)
         (let* ((val (gethash coord hash)))
           (or (null val) (and val (evenp val))))))

     (defun get-hash-keys (hash)
       (loop for key being the hash-keys of hash collect key))

     (defun refresh-hash (hash)
       ;; need to take this approach because we can't add/modify/remove entries of a
       ;; hash table when iterating through it, except for the current entry pointed
       ;; to by the iteration.
       (let ((coords (get-hash-keys hash)))
         (loop for coord in coords
            if (black-p coord hash)
            do (let ((neighbours (get-neighbours coord)))
                 (setf (gethash coord hash) 1)
                 (loop for neighbour in neighbours
                    for val = (gethash neighbour hash)
                    if (null val) do (setf (gethash neighbour hash) 0)
                    else do (setf (gethash neighbour hash) (mod val 2))))
            finally (return hash))))

     (defun two-norm (coord1 coord2)
       (let ((x0 (car coord1))
             (x1 (cdr coord1))
             (y0 (car coord2))
             (y1 (cdr coord2)))
         (sqrt (+ (expt (- x0 y0) 2) (expt (- x1 y1) 2)))))

     (defun pairwise-distances (hash)
       (loop for coord1 being the hash-keys of hash
          collect (loop for coord2 being the hash-keys of hash
                     for dist = (two-norm coord1 coord2)
                     if (> dist 0)
                     collect (cons (list coord1 coord2) dist))
          into result
          finally (return (sort (apply #'append result) #'< :key #'cdr))))

     (defun flip-black-p (coord hash)
       "Determine if black tile at COORD should be flipped to white."
       (when (black-p coord hash)
         (let ((num-black-neighbours (num-black-neighbours coord hash)))
           (or (= num-black-neighbours 0) (> num-black-neighbours 2)))))

     (defun flip-white-p (coord hash)
       "Determine if white tile at COORD should be flipped to black."
       (when (white-p coord hash)
         (let ((num-black-neighbours (num-black-neighbours coord hash)))
           (= num-black-neighbours 2))))

     (defun update-tiles (hash)
       (let ((h (make-hash-table :test #'equal))
             (hash (refresh-hash hash)))
         (loop for coord being the hash-keys of hash
            using (hash-value val)
            if (flip-black-p coord hash)
            do (setf (gethash coord h) 0)
            else if (flip-white-p coord hash)
            do (setf (gethash coord h) 1)
            else if (white-p coord hash)
            do (setf (gethash coord h) 0)
            else ;; if (black-p coord hash)
            do (setf (gethash coord h) 1)
            finally (return h))))

     (defun run-simulation (days &optional debug verbose)
       (let ((hash (build-tile-flip-hash debug)))
         (when verbose (format t "Day 0: ~a~%" (count-black-tiles hash)))
         (when (zerop days)
           (return-from run-simulation hash))
         (loop for i from 1 to days
            with black-tile-count = 0
            do (setf hash (update-tiles hash))
            do (setf black-tile-count (count-black-tiles hash))
            do (when verbose (format t "Day ~a: ~a~%" i black-tile-count))
            finally (return hash))))

     ;;;; final

     (defun day24-part1 (&optional debug)
       (let ((h (build-tile-flip-hash debug)))
         (count-black-tiles h)))

     (defun day24-part2 ()
       (count-black-tiles (run-simulation 100)))

     (verbose1
       (day24-part1)
       (day24-part2))
   #+end_src
   


Try... https://www.redblobgames.com/grids/hexagons/?



** Day xx
   :PROPERTIES:
   :ID:       FF9FD49E-3606-4443-A020-4E2454F05DA5
   :END:

   This is a skeleton for easily creating the next day.

   #+begin_src lisp :exports both :results output :tangle dayxx.lisp :shebang "#!/usr/bin/env sbcl --script"
     (load "my-utils.lisp")


     (defun dayxx-part1 ()
       nil)

     (defun dayxx-part2 ()
       nil)

     (verbose1
       (dayxx-part1)
       (dayxx-part2))
   #+end_src
   




** Extra

   #+begin_src lisp :exports both :results output
     (defun breadth-first-search (other-corners-func)
       (let* ((corners (find-corners))
              (other-corners (funcall other-corners-func corners))
              (starting-corner (set-difference corners other-corners))
              (visited (acons (car starting-corner) 0 nil)))
         (labels ((get-neighbours (tile-name) (get-tile-names-matching tile-name))
                  (get-path-length (node) (cdr (assoc node visited)))
                  (satisfied-p (node) (and (find node other-corners) (<= (get-path-length node) 12)))
                  (set-path-length (node new-path-length) (push (cons node new-path-length) visited))
                  (update-path-length (node new-path-length)
                    (let ((cur-length (get-path-length node)))
                      (when (or (null cur-length) (< new-path-length cur-length))
                        (set-path-length node new-path-length))))
                  (bfs (path)
                    (when (satisfied-p (car path))
                      (return-from breadth-first-search (values path visited)))
                    (when path
                      (let* ((node (car path))
                             (neighbours (get-neighbours node))
                             (new-path-length (1+ (get-path-length node)))
                             (closer-neighbours
                              (remove-if #'(lambda (neighbour)
                                             (let ((nbr-path-len (get-path-length neighbour)))
                                               (when nbr-path-len
                                                 (>= new-path-length (get-path-length neighbour)))))
                                         (remove nil neighbours))))
                        (loop for neighbour in closer-neighbours
                           for new-path = (cons neighbour path)
                           do (update-path-length neighbour new-path-length)
                           do (bfs new-path)
                           until (satisfied-p node))))))
           (bfs starting-corner))))
   #+end_src



   #+begin_src lisp :exports both :results output
     ;;; Interesting loop idiom that I haven't yet seen
     ;; n = 1234 initializes n; the term after `then`
     ;; is used for every other iteration.
     (loop for n = 1234 then (floor n 10)
        until (zerop n)
        collect (mod n 10) into result
        finally (return (reverse result)))
   #+end_src
