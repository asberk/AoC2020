* Advent of Code 2020


  
** Goals

 - I would like to write the whole thing (or as much as possible) in Lisp. Where
   that fails, I may try to use C.

** Resources

   - see this [[https://stackoverflow.com/q/25652002/1456421][this SO post]] for reading in data.
   - See [[https://lispcookbook.github.io/cl-cookbook/iteration.html][lisp cookbook]] for examples of how to use ~LOOP~

** Utilities
   :PROPERTIES:
   :ID:       0B64C670-1156-4BFB-838B-B85F9F9F234C
   :END:


   #+begin_src lisp :exports both :results output :tangle my-utils.lisp
     (defparameter *aoc-dir* "code/aoc20/inputs/")

     (defun get-puzzle-input-fpath (fname)
       "Return ~/code/aoc20/inputs/FNAME"
       (concatenate 'string (namestring (user-homedir-pathname)) *aoc-dir* fname))

     (defun form-length (quoted-form)
       (length (princ-to-string quoted-form)))

     (defun longest-form-length (&rest quoted-forms)
       (loop for f in quoted-forms maximizing (form-length f)))

     (defun verbosify1 (form tablength result)
       "Tries to keep everything on one line."
       (format t "~a~v,0t : -> ~a~%" form tablength result))

     (defun verbosify2 (form result)
       "Two-line formatting"
       (format t "~a~%~2t : -> ~a~%" form result))

     (defmacro verbose1 (&body forms)
       (let ((len-name (gensym)))
         `(let ((,len-name (apply #'longest-form-length ',forms)))
            (progn
              ,@(loop for form in forms
                   collect `(verbosify1 ',form ,len-name ,form))))))

     (defmacro verbose2 (&body forms)
       `(progn
          ,@(loop for form in forms
               collect `(verbosify2 ',form ,form))))

     (defun read-file (filename &optional (reader #'read-line))
       "Read a file from FILENAME and return it as a list of lines."
       (with-open-file (data (get-puzzle-input-fpath filename))
         (loop for line = (funcall reader data nil)
            while line collect line)))

   #+end_src

   #+RESULTS:
  
** Day 1
   :PROPERTIES:
   :ID:       F7024D2A-1593-402A-B1D1-7EF42D3C984D
   :END:


    #+begin_src lisp :exports both :results output :tangle day01.lisp
      (load "my-utils.lisp")

      (defun day1-part1 ()
        ""
        (let ((d1-input (read-file "d1.txt" #'read)))
          (loop named outer-loop
             for a in d1-input
             do (loop for b in d1-input
                   when (= (+ a b) 2020)
                   do (return-from outer-loop (* a b))))))


      (defun day1-part1-method2 ()
        (block loops
          (let ((d1-input (read-file "d1.txt" #'read)))
            (dolist (a d1-input)
              (dolist (b d1-input)
                (when (= (+ a b) 2020)
                  (return-from loops (* a b))))))))

      (defun day1-part2 ()
        (block loops
          (let ((d1-input (read-file "d1.txt" #'read)))
            (dolist (a d1-input)
              (dolist (b d1-input)
                (dolist (c d1-input)
                  (when (= (+ a b c) 2020)
                    (return-from loops (* a b c)))))))))

      (verbose1
        (day1-part1)
        (day1-part1-method2)
        (day1-part2))
    #+end_src

    #+RESULTS:
    : (DAY1-PART1)         : -> 870331
    : (DAY1-PART1-METHOD2) : -> 870331
    : (DAY1-PART2)         : -> 283025088
    
** Day 2
   :PROPERTIES:
   :ID:       FCD2425A-5628-44EB-8AD9-22E127A8A051
   :END:

    #+begin_src lisp :exports both :results output :tangle day02.lisp
      (load "my-utils.lisp")

      (defparameter *day2* (read-file "d2.txt"))

      (defun parse-toboggan-password (line)
        (let ((hyphen-loc (search "-" line))
              (colon-loc (search ": " line)))
          (list
           (parse-integer (subseq line 0 hyphen-loc))
           (read-from-string (subseq line (1+ hyphen-loc)))
           (subseq line (1- colon-loc) colon-loc)
           (subseq line (+ 2 colon-loc)))))

      (defun count-char-occurence (password letter)
        (count-if #'(lambda (c) (string= c letter)) password))

      (defun letter-count-in-bounds-p (lower upper letter-count)
        (<= lower letter-count upper))

      (defun p1-valid-password-p (line)
        (let* ((parsed (parse-toboggan-password line))
               (lower (first parsed))
               (upper (second parsed))
               (letter (third parsed))
               (password (fourth parsed)))
          (letter-count-in-bounds-p
           lower upper (count-char-occurence
                        password letter))))

      (defun extract-letter-from-position (string pos)
        "Note that this is one-indexed as the challenge demands!"
        (subseq string (1- pos) pos))

      (defun xor (a b)
        (and (or a b) (not (and a b))))


      (defun p2-valid-password-p (line)
        (let* ((parsed (parse-toboggan-password line))
               (pos1 (first parsed))
               (pos2 (second parsed))
               (letter (third parsed))
               (password (fourth parsed))
               (letter1 (extract-letter-from-position password pos1))
               (letter2 (extract-letter-from-position password pos2)))
          (xor (string= letter1 letter) (string= letter2 letter))))

      (defun day2-part1 ()
        (count-if #'p1-valid-password-p *day2*))

      (defun day2-part2 ()
        (count-if #'p2-valid-password-p *day2*))

      (verbose1
        (day2-part1)
        (day2-part2))
    #+end_src

    #+RESULTS:
    : (DAY2-PART1) : -> 418
    : (DAY2-PART2) : -> 616

    
** Day 3
   :PROPERTIES:
   :ID:       B4D0AF4C-D061-4E67-BDBA-D3A11E4A62E1
   :END:

   #+begin_src lisp :exports both :results output :tangle day03.lisp
     (load "my-utils.lisp")

     (defun get-char-at-pos (line pos)
       (subseq line pos (1+ pos)))

     (defun tree-p (line pos)
       (string= "#" (get-char-at-pos line pos)))

     (defun build-col-positions (nrows ncols slope)
       "Builds column positions for ski slope. SLOPE should be a cons cell
        corresponding with (right . down)."
       (loop for i from 0 to (ceiling (/ (1- nrows) (cdr slope)))
          collect (mod (* i (car slope)) ncols)))

     (defun row-subset (seq every-other)
       (cond ((< every-other 1) nil)
             ((= every-other 1) seq)
             (t (loop for x in seq
                   for i from 0
                   if (= (mod i every-other) 0)
                   collect x))))

     (defun find-num-trees (data slope)
       "Find the number of trees you'd run into. SLOPE is a cons cell with
        entries (RIGHT . DOWN)."
       (let* ((nr (length data))        ; nrows
              (nc (length (car data)))) ; ncols
         (count t (mapcar #'tree-p (row-subset data (cdr slope))
                          (build-col-positions nr nc slope)))))

     (defun day3-part1 ()
       (find-num-trees (read-file "d3.txt") (cons 3 1)))

     (defun day3-part2 ()
       (let ((day3 (read-file "d3.txt"))
             (slopes (list (cons 1 1) (cons 3 1) (cons 5 1) (cons 7 1) (cons 1 2))))
         (apply #'* (loop for slope in slopes collect (find-num-trees day3 slope)))))

     (verbose1
       (day3-part1)
       (day3-part2))
   #+end_src

   #+RESULTS:
   : (DAY3-PART1) : -> 169
   : (DAY3-PART2) : -> 7560370818

** Day 4
   :PROPERTIES:
   :ID:       3AE5B0B0-212A-4A27-989C-A4416BA78EC9
   :END:

   #+begin_src lisp :exports both :results output :tangle day04.lisp
     (load "my-utils.lisp")

     (defparameter
         ,*required-fields* (list "byr" "iyr" "eyr" "hgt" "hcl" "ecl" "pid")
       "Field names that must be contained in a passport.")

     (defun get-colon-positions (string &optional (start 0))
       "Recursively return a list of indices corresponding to the colons in STRING."
       (let ((start (position #\: string :start start)))
         (cond (start (apply #'list start (get-colon-positions string (1+ start))))
               (t nil))))

     (defun get-field (string colon-loc)
       "Return the passport field associated with a given COLON-LOC."
       (subseq string (- colon-loc 3) colon-loc))

     (defun concat-strings (list)
       "Join a list of strings into one, separated by spaces."
       (if (and (listp list) (every #'stringp list))
           (with-output-to-string (s)
             (format s "~{~a~^ ~}" list))))

     (defun get-fields-from-string (string)
       "Return a list of all found passport fields in STRING."
       (mapcar #'(lambda (colon-loc) (get-field string colon-loc))
               (get-colon-positions string)))

     (defun get-fields-from-batch (batch)
       "Return a list of all found passport fields in BATCH. (helper function.)"
       (get-fields-from-string (concat-strings (reverse batch))))

     (defun on-fields (func fields)
       "Apply FUNC using FIELDS as the sequence against which to test membership."
       (funcall func #'(lambda (x) (member x fields :test #'string=)) *required-fields*))

     (defun num-required-fields (fields)
       "Count number of required fields found in FIELDS."
       (on-fields #'count-if fields))

     (defun contains-required-fields-p (fields)
       "Return T if all required passport fields were found in FIELDS; NIL otherwise."
       (on-fields #'every fields))

     (defun required-fields-p (line)
       "Return T if line contains all required passport fields (cf. *required-fields*)."
       (contains-required-fields-p (get-fields-from-string line)))

     ;; note: for some reason the last batch was not being processed by loop; we need
     ;; to collect it manually using this extra (slightly ugly) code.
     (defun traverse-collecting-field-names (data)
       (let* ((batch nil)
              (results
               (loop for line in data
                  if (string= line "")
                  collect (get-fields-from-batch batch)
                  and do (setf batch nil)
                  else do (push line batch))))
         (cond (batch (append results (list (get-fields-from-batch batch))))
               (t results))))

          ;;; code for part 2

     (defun lineify (data)
       "Transform DATA so that one passport entry corresponds with one string in the returned list."
       (let* ((batch nil)
              (results
               (loop for line in data
                  if (string= line "")
                  collect (concat-strings (reverse batch))
                  and do (setf batch nil)
                  else do (push line batch))))
         (cond (batch (append results (list (concat-strings (reverse batch)))))
               (t results))))

     (defun whitespacep (c)
       "Return T if C is a space or newline character."
       (or (char= c #\Space) (char= c #\Newline)))

     (defun colonp (c)
       "Return T if C is a colon character."
       (char= c #\:))

     (defun split-string (string &optional (predicate #'whitespacep))
       "Split STRING into multiple strings at the locations determined by
             PREDICATE. Default is to split at spaces/newlines."
       (let ((locs (loop for c across string for i from 0 if (funcall predicate c) collect i)))
         (setf locs (concatenate 'list (list 0) locs (list (length string))))
         (loop for i0 in locs
            for i1 in (cdr locs)
            collect (remove-if predicate (subseq string i0 i1)))))

     (defun parse-field-names-values (line)
       "Return a list of '(key value) lists for each key provided in LINE."
       (mapcar #'(lambda (x) (split-string x #'colonp)) (split-string line)))

     (defun string-number-in-bounds-p (string lower upper)
       "Determine if STRING represents a number that lies between lower and
             upper (inclusive)."
       (let ((n (parse-integer string :junk-allowed t)))
         (when n (<= lower n upper))))

     (defun valid-byr-p (byr)
       "Validate passport birth year IYR."
       (string-number-in-bounds-p byr 1920 2002))

     (defun valid-iyr-p (iyr)
       "Validate passport issue year IYR."
       (string-number-in-bounds-p iyr 2010 2020))

     (defun valid-eyr-p (eyr)
       "Validate passport expiration year EYR."
       (string-number-in-bounds-p eyr 2020 2030))

     (defun valid-hgt-p (hgt)
       "Validate height HEIGHT."
       (cond ((search "cm" hgt) (string-number-in-bounds-p hgt 150 193))
             ((search "in" hgt) (string-number-in-bounds-p hgt 59 76))
             (t nil)))

     (defun valid-hcl-p (hcl)
       "Validate hair colour HCL."
       (let ((hash-pos (position #\# hcl)) )
         (and hash-pos (= hash-pos 0) (= (length hcl) 7)
              (every
               #'(lambda (c) (position c "1234567890abcdef"))
               (subseq hcl 1)))))

     (defun valid-ecl-p (ecl)
       "Validate eye colour ECL."
       (not (null (member ecl (list "amb" "blu" "brn" "gry" "grn" "hzl" "oth") :test #'string=))))

     (defun valid-pid-p (pid)
       "Validate a passport id PID."
       (and (= (length pid) 9) (every #'(lambda (c) (position c "1234567890")) pid)))

     (defun valid-cid-p (cid) "Ignore CID entries and return T." t)

     (defun select-validator (field-name)
       "Select a validator to use according to FIELD-NAME."
       (cond ((string= field-name "byr") #'valid-byr-p)
             ((string= field-name "iyr") #'valid-iyr-p)
             ((string= field-name "eyr") #'valid-eyr-p)
             ((string= field-name "hgt") #'valid-hgt-p)
             ((string= field-name "hcl") #'valid-hcl-p)
             ((string= field-name "ecl") #'valid-ecl-p)
             ((string= field-name "pid") #'valid-pid-p)
             ((string= field-name "cid") #'valid-cid-p)
             (t (format t "Error: could not parse field name") nil)))

     (defun validate-field (field-kv)
       "Validate a passport key-value pair FIELD-KV, a two-element list."
       (funcall (select-validator (car field-kv)) (cadr field-kv)))

     (defun all-field-values-valid-p (line)
       "Validate all provided passport fields in LINE."
       (let ((parsed (parse-field-names-values line)))
         (every #'validate-field parsed)))

     (defun valid-passport-p (line)
       "Determine if LINE corresponds to a valid passport."
       (and (required-fields-p line) (all-field-values-valid-p line)))

     (defun day4-part1 ()
       (count 7 (mapcar #'num-required-fields
                        (traverse-collecting-field-names (read-file "d4.txt")))))

     (defun day4-part2 ()
       (count-if #'valid-passport-p (lineify (read-file "d4.txt"))))

     (verbose1 
       (day4-part1)
       (day4-part2))

   #+end_src

   #+RESULTS:
   : (DAY4-PART1) : -> 245
   : (DAY4-PART2) : -> 133

   
** Day 5
   :PROPERTIES:
   :ID:       D5D0FDF6-828E-400F-8DBF-FFCEF6F96A4E
   :END:

   #+begin_src lisp :exports both :results output :tangle day05.lisp
     (load "my-utils.lisp")

     (defparameter *test-cases* (list "FBFBBFFRLR" "BFFFBBFRRR" "FFFBBBFRRR" "BBFFBBFRLL"))
     (defparameter *test-seat-ids* (list 357 567 119 820))


     (defun front-or-back-p (c)
       (or (char-equal c #\b) (char-equal c #\f)))

     (defun front-or-back (c)
       (cond ((char-equal c #\b) 1)
             ((char-equal c #\f) 0)
             (t nil)))

     (defun left-or-right (c)
       (cond ((char-equal c #\r) 1)
             ((char-equal c #\l) 0)
             (t nil)))

     (defun get-bit-from-character (c)
       (or (front-or-back c) (left-or-right c)))

     (defun get-bit-string (string)
       (loop for c across string collect (get-bit-from-character c)))

     (defun get-integer-from-bit-string (bit-string)
       (apply #'+ (loop for b in (reverse bit-string)
                     for j from 0
                     if (= b 1)
                     collect (expt 2 j))))

     (defun left-right-substr (string)
       (remove-if #'front-or-back-p string))

     (defun front-back-substr (string)
       (remove-if (complement #'front-or-back-p) string))

     (defun get-row-from-string (string)
       (get-integer-from-bit-string (get-bit-string (front-back-substr string))))

     (defun get-column-from-string (string)
       (get-integer-from-bit-string (get-bit-string (left-right-substr string))))

     (defun seat-id (string)
       (+ (* 8 (get-row-from-string string)) (get-column-from-string string)))

     (defun check-test-cases ()
       (when (notevery #'= (mapcar #'seat-id *test-cases*) *test-seat-ids*)
         (format t "Error: test cases did not pass")))

     (check-test-cases)

     (defun day5-part1 (&optional (data (read-file "d5.txt")))
       (loop for line in data maximizing (seat-id line)))

     (defun day5-part2 ()
       (let* ((day5 (read-file "d5.txt"))
              (parsed (mapcar #'seat-id day5))
              (max-id (apply #'max parsed))
              (found (loop for i from 1 to max-id
                        if (and (not (member i parsed))
                                (member (1- i) parsed)
                                (member (1+ i) parsed))
                        collect i)))
         (when (= (length found) 1)
           (car found))))

     (verbose1
       (day5-part1)
       (day5-part2))


   #+end_src

   #+RESULTS:
   : (DAY5-PART1) : -> 894
   : (DAY5-PART2) : -> 579

** Day 6
   :PROPERTIES:
   :ID:       3B91A8DA-B7D5-4114-8E27-B15B10E30F6B
   :END:


   #+begin_src lisp :exports both :results output :tangle day06.lisp
     (load "my-utils.lisp")

     (defparameter *day6* (read-file "d6.txt") "Day 6 puzzle input")
     (defvar *lower*
       (loop with a = (char-code #\a)
             for i below 26
          collect (code-char (+ a i))))

     (ql:quickload 'split-sequence :silent t)

     (defun split-input-by-groups (data)
       "Return a list of lists from DATA, assuming each entry is a string."
       (split-sequence:split-sequence
        0 data :key #'(lambda (x) (length x))))

     (defun output-formatter (string)
       (when string
         (sort (copy-seq (remove-duplicates string)) #'string<)))

     (defun parse-group-any (group)
       "Return GROUP as all found questions with duplicates removed."
       (output-formatter (apply #'concatenate 'string group)))

     (defun parse-group-every (group)
       "Return GROUP as all questions found for every GROUP member."
       (output-formatter
        (cond
          ((= (length group) 1) (car group))
          ((< (length group) 0) nil)
          (t (format nil "~{~A~}"
                     (loop for letter across (car group)
                        if (every #'(lambda (x) (position letter x))
                                  (cdr group))
                        collect letter))))))

     (defun num-questions (data group-parser)
       (apply #'+ (mapcar
                   (lambda (x) (length (funcall group-parser x)))
                   (split-input-by-groups data))))

     (defun day6-part1 ()
       (num-questions *day6* #'parse-group-any))

     (defun day6-part2 ()
       (num-questions *day6* #'parse-group-every))

     (verbose1
       (day6-part1)
       (day6-part2))


   #+end_src

   #+RESULTS:
   : (DAY6-PART1) : -> 6630
   : (DAY6-PART2) : -> 3437

** Day 7
   :PROPERTIES:
   :ID:       8E06349D-A4FD-4E83-B01C-9E8D66F7C4ED
   :END:


   #+begin_src lisp :exports both :results output :tangle day07.lisp
     (load "my-utils.lisp")

     (defparameter *day7* (read-file "d7.txt"))

     ;;;; preprocessing

     (ql:quickload 'split-sequence :silent t)

     (defun split-input-by-groups (data)
       "Return a list of lists from DATA, assuming each entry is a string."
       (split-sequence:split-sequence
        0 data :key #'(lambda (x) (length x))))

     (defun split-parent-child (line)
       (let* ((i0 (search " bags contain " line))
              (i1 (+ i0 14))
              (i2 (1- (length line))))
         (list (subseq line 0 i0) (subseq line i1 i2))))

     (defun no-other-bags-p (children-string)
       (search "no other bags" children-string))

     (defun remove-leading-space (string)
       "docstring"
       (let ((space-pos (position #\Space string)))
         (cond ((and space-pos (= space-pos 0)) (subseq string 1))
               (t string))))

     (defun split-children (children-string)
       "Split a string of all children into a list of each child item"
       (cond ((no-other-bags-p children-string) nil)
             (t (mapcar
                 #'remove-leading-space
                 (split-sequence:split-sequence #\, children-string)))))

     (defun parse-child (child-string)
       (let ((child (split-sequence:split-sequence #\Space child-string)))
         (cons
          (concatenate 'string (cadr child) " " (caddr child))
          (parse-integer (car child)))))

     (defun parse-line (line)
       (let* ((parent-children (split-parent-child line))
              (parent          (car parent-children))
              (children        (split-children (cadr parent-children))))
         (cons (car parent-children)
               (cond (children (mapcar #'parse-child children))
                     (t nil)))))

     (defparameter *data* (mapcar #'parse-line *day7*))

     ;;;; part 1

     (defun mk-contains-colour-p (colour)
       (lambda (entry) (assoc colour (cdr entry) :test #'string=)))

     (defun mk-get-containing-colour (colour)
       (lambda (entry)
         (when (funcall (mk-contains-colour-p colour) entry)
           (car entry))))

     (defun get-containing-colours (data &optional (colour "shiny gold"))
       (remove nil (mapcar (mk-get-containing-colour colour) data)))

     (defun remove-visited (data visited)
       (remove-if #'(lambda (x) (member (car x) visited :test #'string=)) data))

     (defun search-visited (all-visited colours data)
       (let* ((new-data (remove-visited data colours))
              (new-colours
               (mapcan #'(lambda (colour)
                           (get-containing-colours new-data colour))
                       colours)))
         (cond ((and new-colours (> (length new-data) 0))
                (search-visited (append all-visited new-colours) new-colours new-data))
               (t (remove-duplicates all-visited)))))

     ;;;; Part 2

     (defun get-contained-bags (data colour)
       "Return a list of cons cells representing the bag colours and their required
     numbers for a COLOUR bag."
       (cdr (assoc colour data :test #'string=)))

     (defun bag-counter (data item)
       "Return the number of bags + the number of bags inside each of those bags."
       (let ((bag-colour (car item))
             (num-bags   (cdr item)))
         (+ num-bags (* num-bags (count-bags-inside bag-colour data)))))

     (defun count-bags-helper (data contained-bags)
       "Apply BAG-COUNTER to each bag colour in CONTAINED-BAGS and sum the result."
       (apply #'+ (mapcar #'(lambda (item) (bag-counter data item)) contained-bags)))

     (defun count-bags-inside (colour data)
       "Count the number of bags required inside a COLOUR bag."
       (let ((contained-bags (get-contained-bags data colour)))
         (cond (contained-bags (count-bags-helper data contained-bags))
               (t 0))))

     ;;;; final

     (defun day7-part1 ()
       (length (search-visited nil (list "shiny gold") *data*)))

     (defun day7-part2 ()
       (count-bags-inside "shiny gold" *data*))

     (verbose1
       (day7-part1)
       (day7-part2))
   #+end_src

   #+RESULTS:
   : (DAY7-PART1) : -> 177
   : (DAY7-PART2) : -> 34988
   
** Day 08
   :PROPERTIES:
   :ID:       8CDD83AE-801E-483C-86AF-B40592D0E595
   :END:


   #+begin_src lisp :exports both :results output :tangle day08.lisp
     (load "my-utils.lisp")
     (ql:quickload 'split-sequence :silent t)

     (defun parse-instruction (line)
       (destructuring-bind (inst val) (split-sequence:split-sequence #\Space line)
         (cons (read-from-string inst) (parse-integer val))))

     (defparameter *day8* (read-file "d8.txt"))
     (defparameter *accumulator* 0)
     (defparameter *pointer* 0)
     (defparameter *instructions*
       (make-array (length *day8*) :initial-contents (mapcar #'parse-instruction *day8*)))
     (defparameter *running* t)
     (defparameter *visited* nil)

     (defun jmp (&optional (val 1)) (incf *pointer* val))

     (defun acc (val)
       (jmp)
       (incf *accumulator* val))

     (defun nop (&optional val) (jmp))

     (defun get-inst ()
       (cond ((<= 0 *pointer* (1- (length *instructions*)))
              (aref *instructions* *pointer*))
             (t
              (format t "pointer out of bounds with value ~a~%" *pointer*)
              (format t "accumulator has value: ~a.~%" *accumulator*)
              nil)))

     (defun check-visited ()
       (cond ((find *pointer* *visited*)
              (setf *running* nil)
              ,*accumulator*)
             (*running*
              (push *pointer* *visited*)
              nil)))

     (defun eval-instruction (inst)
       "Evaluate INST if non-nil."
       (let ((output-val (check-visited)))
         (cond (output-val output-val)
               (inst (funcall (car inst) (cdr inst)))
               (t nil))))

     (defun reset-runtime ()
       "Reset runtime variables to initial states."
       (setf *accumulator* 0)
       (setf *pointer* 0)
       (setf *visited* nil)
       (setf *running* t))

     ;;;; part 2

     ;;; it stands to reason that we only need to change one of the entries in
     ;;; *visited* with jmp <--> nop. That leaves <=211 possibilities
     (defun get-swap-candidates ()
       "Build list of candidates for part 2 swapping."
       (day08-part1)
       (remove-if-not #'(lambda (x) (or (eql x 'jmp) (eql x 'nop)))
                      ,*visited* :key #'get-inst-type))

     (defun get-inst-symbol (pointer-val)
       "Gets the instruction symbol associated with POINTER-VAL"
       (when (<= 0 pointer-val (1- (length *instructions*)))
         (car (aref *instructions* pointer-val))))

     (defun set-inst-symbol (pointer-val new-inst)
       "Set symbol at POINTER-VAL to NEW-INST."
       (when (or (eql 'jmp new-inst) (eql 'nop new-inst))
         (setf (aref *instructions* pointer-val)
               (cons new-inst (cdr (aref *instructions* pointer-val))))))

     (defun swap-inst-symbol (pointer-val)
       "Swap 'JMP for 'NOP and vice versa at POINTER-VAL (or return NIL)."
       (let ((inst-func (get-inst-symbol pointer-val)))
         (cond ((eql inst-func 'jmp) (set-inst-symbol pointer-val 'nop))
               ((eql inst-func 'nop) (set-inst-symbol pointer-val 'jmp))
               (t nil))))

     (defun eval-if-valid ()
       "Eval instruction associated with *pointer* only if *pointer* is
     valid. Otherwise, stop runtime and return *accumulator* value."
       (cond ((<= 0 *pointer* (1- (length *instructions*)))
              (eval-instruction (get-inst)))
             (t (setf *running* nil)
                ,*accumulator*)))

     (defun execute-swapped-runtime (swap-index)
       (reset-runtime)
       (swap-inst-symbol swap-index)
       (let ((result
              (loop until (not *running*)
                 for x = (eval2-if-valid)
                 finally (return x))))
         (swap-inst-symbol swap-index) ;; swap back!
         result))

     ;;;; final

     (defun day08-part1 ()
       (reset-runtime)
       (loop until (not *running*)
          for x = (eval-instruction (get-inst))
          finally (return x)))


     (defun day08-part2 ()
       (loop for swap-idx in (get-swap-candidates)
          for x = (execute-swapped-runtime swap-idx)
          until x
          finally (return x)))

     (verbose1
       (day08-part1)
       (day08-part2))
   #+end_src

   #+RESULTS:
   : (DAY08-PART1) : -> 1451
   : (DAY08-PART2) : -> 1160
   
** Day 09
   :PROPERTIES:
   :ID:       F755144D-8EBA-4839-A607-8EBCA4249F06
   :END:


   #+begin_src lisp :exports both :results output :tangle day09.lisp
     (load "my-utils.lisp")

     ;;;; def

     (defparameter *day9* (mapcar #'read-from-string (read-file "d9.txt")))
     (defparameter *preamble (subseq *day9* 0 25))
     (defparameter *numbers* (make-array (length *day9*) :initial-contents *day9*))
     (defparameter *cur* 25)
     (defparameter *magic-number* 177777905)

     ;;;; part 1

     (defun range (n &key (start 0))
       (when (and (numberp n) (>= n 0))
         (loop for i from start below n collect i)))

     (defun validate-at-index (index)
       (when (>= (1- (length *numbers*)) index 25)
         (let ((prev (subseq *numbers* (- index 25) index))
               (cur (aref *numbers* index)))
           (loop for a across prev
              do (loop for b across prev
                    if (and (/= b a) (= (+ b a) cur))
                    do (return-from validate-at-index (+ b a)))))))

     ;;;; part 2

     (defun too-small-p (value)
       (< value *magic-number*))

     (defun too-large-p (value)
       (> value *magic-number*))

     (defun get-value (index)
       (aref *numbers* index))

     (defparameter *contig* nil)

     (defun append-right (value) (setf *contig* (append *contig* (list value))))

     (defun pop-left ()
       (let ((ret (car *contig*)))
         (setf *contig* (cdr *contig*))
         ret))

     (defun get-sum ()
       (apply #'+ *contig*))

     (defun search-for-contiguous-sum (&optional (left-idx 0) (right-idx 0))
       "Find a contiguous block of numbers whose sum is equals *MAGIC-NUMBER* (found in Part 1)."
         (cond ((too-small-p (get-sum))              ; if the sum is too small, 
                (append-right (get-value right-idx)) ; add the next number to the block
                (search-for-contiguous-sum left-idx (1+ right-idx))) ; & try again
               ((too-large-p (get-sum)) ; if the sum is too small,
                (pop-left)              ; remove the first number in the block
                (search-for-contiguous-sum (1+ left-idx) right-idx)) ; & try again
               ((>= (length *contig*) 2) ; >= 2 contiguous numbers with desired sum
                (+ (apply #'min *contig*) (apply #'max *contig*))) ; yay!
               (t (append-right (get-value right-idx))     ; keep trying!
                  (search-for-contiguous-sum left-idx (1+ right-idx)))))

     ;;;; final

     (defun day09-part1 ()
       (let ((indices (range (length *numbers*) :start 25)))
         (loop for index in indices
            while (validate-at-index index)
            finally (return (aref *numbers* index)))))

     (defun day09-part2 ()
       (defparameter *contig* nil)
       (search-for-contiguous-sum))

     (verbose1
       (day09-part1)
       (day09-part2))
   #+end_src

   #+RESULTS:
   : (DAY09-PART1) : -> 177777905
   : (DAY09-PART2) : -> 23463012
   

*** Notes

    There is a potential bottleneck in ~APPEND-RIGHT~. Namely, I'm using ~APPEND~ to
    add an element to the end of a list. If the list is long, and/or the
    function is called a lot this could slow things down (because ~APPEND~ has to
    traverse the whole list each time). A way of speeding this up (subject to a
    bit of added complexity) is available in [[https://stackoverflow.com/a/6482598/1456421][this SO post]]. For example,

    #+begin_src lisp :exports both :results output
      (defparameter *contig* nil)
      (defparameter *contig-tail* *contig*)

      ;;; if *contig* is nil it has no tail and so we can't append-right;
      ;;; do a normal PUSH instead.
      (defun append-right--contig (value)
        (cond (*contig-tail*
               (setf (cdr *contig-tail*) (cons value nil))
               (setf *contig-tail* (cdr *contig-tail*)))
              (t (push value *contig*)
                 (setf *contig-tail* *contig*))))

      ;;; APPEND-RIGHT only makes sense when the list is non-nil, else there is no
      ;;; "right" to append to. In this case, start with a usual PUSH and then use
      ;;; APPEND-RIGHT.
      (defun append-right (tail value)
        (when tail
          (setf (cdr tail) (cons value nil))
          (setf tail (cdr tail))
          tail))

      ;;;; Example
      (append-right--contig 0)
      (append-right--contig 1)
      (append-right--contig 2)
      (append-right--contig 3)

      (format t "~{~a~^, ~}~%" *contig*)
      (format t "~{~a~^, ~}~%" *contig-tail*)
    #+end_src

    #+RESULTS:
    : 0, 1, 2, 3
    : 3

** Day 10
   :PROPERTIES:
   :ID:       660CD373-3858-4F42-AEF5-C044B4E5E0E9
   :END:

   #+begin_src lisp :exports both :results output :tangle day10.lisp
     ;; (load "my-utils.lisp")

     (ql:quickload 'split-sequence :silent t)

     (defparameter *day10* (mapcar #'parse-integer (read-file "d10.txt")))
     (defparameter *device-joltage* (+ 3 (apply #'max *day10*)))


     (defun sorted-joltages ()
       (sort (copy-seq *day10*) #'<))

     (defparameter *sorted-joltages*
       (append (list 0) (sorted-joltages) (list *device-joltage*))
       "Includes outlet joltage and device joltage")

     ;;;; Part 1

     (defun diff-func (seq)
       "Compute x1 - x0 where x0 is the first element of SEQ."
       (if (cadr seq)
           (- (cadr seq) (car seq))
           nil))

     (defun diff (seq)
       "Computes the differences between consecutive elements in SEQ."
       (remove nil (maplist #'diff-func seq)))


     ;;;; Part 2

     (defparameter *tribonacci-alist* nil)

     (defun compute-tribonacci--alist (n)
       "Return n-th tribonacci number, computing recursively and using alist
     memoization. Helper function for tribonacci--alist."
       (let ((t-n (+ (tribonacci--alist (- n 1))
                     (tribonacci--alist (- n 2))
                     (tribonacci--alist (- n 3)))))
         (push (cons n t-n) *tribonacci-alist*)
         t-n))

     (defun tribonacci--alist (n)
       "Return the nth tribonacci number using memoization for speed-up."
       (cond
         ((or (not (numberp n)) (< n 0)) (format t "N must be a nonnegative integer.~%"))
         ((<= 0 n 1) 1) ((= n 2) 2)
         ((> n 2)
          (let ((t-n (cdr (assoc n *tribonacci-alist*))))
            (if t-n t-n
                (compute-tribonacci--alist n))))))


     ;;;; final

     (defun day10-part1 ()
       (let ((diffs (diff *sorted-joltages*)))
         (* (count 1 diffs) (count 3 diffs))))

     (defun day10-part2 ()
       "We can view the effect of removing adapters through the diffs. Namely, it's
     equivalent to 'merging' contiguous 1s into 2s or 3s (and no higher, as per the
     problem requirements). It so happens that finding the number of possible
     mergings for a contiguous block of 1s of length n is given by the nth tribonacci
     number. Simply multiply together the tribonacci number associated to each
     contiguous block of 1s to obtain the result.

     Examples are provided for contiguous 1 blocks of length 1 through 5:

     1  [1]: (1)
     2  [2]: (1 1)       (2)
     3  [4]: (1 1 1)     (2 1)     (1 2)      (3)
     4  [7]: (1 1 1 1)   (2 1 1)   (1 2 1)    (1 1 2)   (2 2)     
             (3 1)       (1 3)
     5 [13]: (1 1 1 1 1) (2 1 1 1) (1 2 1 1)  (1 1 2 1) (1 1 1 2)
             (2 2 1)     (2 1 2)   (1 2 2)    (3 1 1)   (1 3 1)   
             (1 1 3)     (3 2)     (2 3)"
       (let* ((diffs (diff *sorted-joltages*))
              (contig-1s (split-sequence:split-sequence 3 diffs))
              (block-lengths (remove 0 (mapcar #'length contig-1s))))
         (apply #'* (mapcar #'tribonacci--alist block-lengths))))

     (verbose1
       (day10-part1)
       (day10-part2))
   #+end_src

   #+RESULTS:
   : (DAY10-PART1) : -> 1980
   : (DAY10-PART2) : -> 4628074479616


   #+begin_src lisp :exports both :results output
     ;;; hash table implementation of the tribonacci function, just for fun.

     (defparameter *tribonacci-hash* (make-hash-table))

     (defun compute-tribonacci--hash (n)
       "Return n-th tribonacci number, computing recursively and using hash table
     memoization. Helper function for tribonacci--hash."
       (setf (gethash n *tribonacci-hash*)
             (+ (tribonacci--hash (- n 1))
                (tribonacci--hash (- n 2))
                (tribonacci--hash (- n 3)))))

     (defun tribonacci--hash (n)
       "Return the nth tribonacci number using memoization for speed-up."
       (when n
         (cond
           ((or (not (numberp n)) (< n 0)) (format t "N must be a nonnegative integer.~%"))
           ((<= 0 n 1) 1) ((= n 2) 2)
           ((> n 2)
            (let ((t-n (gethash n *tribonacci-hash*)))
              (if t-n t-n (compute-tribonacci--hash n)))))))
   #+end_src

** Day xx
   :PROPERTIES:
   :ID:       FF9FD49E-3606-4443-A020-4E2454F05DA5
   :END:

   This is a skeleton for easily creating the next day.

   #+begin_src lisp :exports both :results output :tangle dayxx.lisp
     (load "my-utils.lisp")


     (defun dayxx-part1 ()
       nil)

     (defun dayxx-part2 ()
       nil)

     (verbose1
       (dayxx-part1)
       (dayxx-part2))
   #+end_src
   
