* Advent of Code 2020


  
** Goals

 - I would like to write the whole thing (or as much as possible) in Lisp. Where
   that fails, I may try to use C.

** Resources

   - see this [[https://stackoverflow.com/q/25652002/1456421][this SO post]] for reading in data.
   - See [[https://lispcookbook.github.io/cl-cookbook/iteration.html][lisp cookbook]] for examples of how to use ~LOOP~

** Utilities
   :PROPERTIES:
   :ID:       0B64C670-1156-4BFB-838B-B85F9F9F234C
   :END:


   #+begin_src lisp :exports both :results output :tangle my-utils.lisp
     (defparameter *aoc-dir* "code/aoc20/inputs/")

     (defun get-puzzle-input-fpath (fname)
       "Return ~/code/aoc20/inputs/FNAME"
       (concatenate 'string (namestring (user-homedir-pathname)) *aoc-dir* fname))

     (defun form-length (quoted-form)
       (length (princ-to-string quoted-form)))

     (defun longest-form-length (&rest quoted-forms)
       (loop for f in quoted-forms maximizing (form-length f)))

     (defun verbosify1 (form tablength result)
       "Tries to keep everything on one line."
       (format t "~a~v,0t : -> ~a~%" form tablength result))

     (defun verbosify2 (form result)
       "Two-line formatting"
       (format t "~a~%~2t : -> ~a~%" form result))

     (defmacro verbose1 (&body forms)
       (let ((len-name (gensym)))
         `(let ((,len-name (apply #'longest-form-length ',forms)))
            (progn
              ,@(loop for form in forms
                   collect `(verbosify1 ',form ,len-name ,form))))))

     (defmacro verbose2 (&body forms)
       `(progn
          ,@(loop for form in forms
               collect `(verbosify2 ',form ,form))))

     (defun read-file (filename &optional (reader #'read-line))
       "Read a file from FILENAME and return it as a list of lines."
       (with-open-file (data (get-puzzle-input-fpath filename))
         (loop for line = (funcall reader data nil)
            while line collect line)))

   #+end_src

   #+RESULTS:
  
** Day 1
   :PROPERTIES:
   :ID:       F7024D2A-1593-402A-B1D1-7EF42D3C984D
   :END:


    #+begin_src lisp :exports both :results output :tangle day01.lisp
      (load "my-utils.lisp")

      (defun day1-part1 ()
        ""
        (let ((d1-input (read-file "d1.txt" #'read)))
          (loop named outer-loop
             for a in d1-input
             do (loop for b in d1-input
                   when (= (+ a b) 2020)
                   do (return-from outer-loop (* a b))))))


      (defun day1-part1-method2 ()
        (block loops
          (let ((d1-input (read-file "d1.txt" #'read)))
            (dolist (a d1-input)
              (dolist (b d1-input)
                (when (= (+ a b) 2020)
                  (return-from loops (* a b))))))))

      (defun day1-part2 ()
        (block loops
          (let ((d1-input (read-file "d1.txt" #'read)))
            (dolist (a d1-input)
              (dolist (b d1-input)
                (dolist (c d1-input)
                  (when (= (+ a b c) 2020)
                    (return-from loops (* a b c)))))))))

      (verbose1
        (day1-part1)
        (day1-part1-method2)
        (day1-part2))
    #+end_src

    #+RESULTS:
    : (DAY1-PART1)         : -> 870331
    : (DAY1-PART1-METHOD2) : -> 870331
    : (DAY1-PART2)         : -> 283025088
    
** Day 2
   :PROPERTIES:
   :ID:       FCD2425A-5628-44EB-8AD9-22E127A8A051
   :END:

    #+begin_src lisp :exports both :results output :tangle day02.lisp
      (load "my-utils.lisp")

      (defparameter *day2* (read-file "d2.txt"))

      (defun parse-toboggan-password (line)
        (let ((hyphen-loc (search "-" line))
              (colon-loc (search ": " line)))
          (list
           (parse-integer (subseq line 0 hyphen-loc))
           (read-from-string (subseq line (1+ hyphen-loc)))
           (subseq line (1- colon-loc) colon-loc)
           (subseq line (+ 2 colon-loc)))))

      (defun count-char-occurence (password letter)
        (count-if #'(lambda (c) (string= c letter)) password))

      (defun letter-count-in-bounds-p (lower upper letter-count)
        (<= lower letter-count upper))

      (defun p1-valid-password-p (line)
        (let* ((parsed (parse-toboggan-password line))
               (lower (first parsed))
               (upper (second parsed))
               (letter (third parsed))
               (password (fourth parsed)))
          (letter-count-in-bounds-p
           lower upper (count-char-occurence
                        password letter))))

      (defun extract-letter-from-position (string pos)
        "Note that this is one-indexed as the challenge demands!"
        (subseq string (1- pos) pos))

      (defun xor (a b)
        (and (or a b) (not (and a b))))


      (defun p2-valid-password-p (line)
        (let* ((parsed (parse-toboggan-password line))
               (pos1 (first parsed))
               (pos2 (second parsed))
               (letter (third parsed))
               (password (fourth parsed))
               (letter1 (extract-letter-from-position password pos1))
               (letter2 (extract-letter-from-position password pos2)))
          (xor (string= letter1 letter) (string= letter2 letter))))

      (defun day2-part1 ()
        (count-if #'p1-valid-password-p *day2*))

      (defun day2-part2 ()
        (count-if #'p2-valid-password-p *day2*))

      (verbose1
        (day2-part1)
        (day2-part2))
    #+end_src

    #+RESULTS:
    : (DAY2-PART1) : -> 418
    : (DAY2-PART2) : -> 616

    
** Day 3
   :PROPERTIES:
   :ID:       B4D0AF4C-D061-4E67-BDBA-D3A11E4A62E1
   :END:

   #+begin_src lisp :exports both :results output :tangle day03.lisp
     (load "my-utils.lisp")

     (defun get-char-at-pos (line pos)
       (subseq line pos (1+ pos)))

     (defun tree-p (line pos)
       (string= "#" (get-char-at-pos line pos)))

     (defun build-col-positions (nrows ncols slope)
       "Builds column positions for ski slope. SLOPE should be a cons cell
        corresponding with (right . down)."
       (loop for i from 0 to (ceiling (/ (1- nrows) (cdr slope)))
          collect (mod (* i (car slope)) ncols)))

     (defun row-subset (seq every-other)
       (cond ((< every-other 1) nil)
             ((= every-other 1) seq)
             (t (loop for x in seq
                   for i from 0
                   if (= (mod i every-other) 0)
                   collect x))))

     (defun find-num-trees (data slope)
       "Find the number of trees you'd run into. SLOPE is a cons cell with
        entries (RIGHT . DOWN)."
       (let* ((nr (length data))        ; nrows
              (nc (length (car data)))) ; ncols
         (count t (mapcar #'tree-p (row-subset data (cdr slope))
                          (build-col-positions nr nc slope)))))

     (defun day3-part1 ()
       (find-num-trees (read-file "d3.txt") (cons 3 1)))

     (defun day3-part2 ()
       (let ((day3 (read-file "d3.txt"))
             (slopes (list (cons 1 1) (cons 3 1) (cons 5 1) (cons 7 1) (cons 1 2))))
         (apply #'* (loop for slope in slopes collect (find-num-trees day3 slope)))))

     (verbose1
       (day3-part1)
       (day3-part2))
   #+end_src

   #+RESULTS:
   : (DAY3-PART1) : -> 169
   : (DAY3-PART2) : -> 7560370818

** Day 4
   :PROPERTIES:
   :ID:       3AE5B0B0-212A-4A27-989C-A4416BA78EC9
   :END:

   #+begin_src lisp :exports both :results output :tangle day04.lisp
     (load "my-utils.lisp")

     (defparameter
         ,*required-fields* (list "byr" "iyr" "eyr" "hgt" "hcl" "ecl" "pid")
       "Field names that must be contained in a passport.")

     (defun get-colon-positions (string &optional (start 0))
       "Recursively return a list of indices corresponding to the colons in STRING."
       (let ((start (position #\: string :start start)))
         (cond (start (apply #'list start (get-colon-positions string (1+ start))))
               (t nil))))

     (defun get-field (string colon-loc)
       "Return the passport field associated with a given COLON-LOC."
       (subseq string (- colon-loc 3) colon-loc))

     (defun concat-strings (list)
       "Join a list of strings into one, separated by spaces."
       (if (and (listp list) (every #'stringp list))
           (with-output-to-string (s)
             (format s "~{~a~^ ~}" list))))

     (defun get-fields-from-string (string)
       "Return a list of all found passport fields in STRING."
       (mapcar #'(lambda (colon-loc) (get-field string colon-loc))
               (get-colon-positions string)))

     (defun get-fields-from-batch (batch)
       "Return a list of all found passport fields in BATCH. (helper function.)"
       (get-fields-from-string (concat-strings (reverse batch))))

     (defun on-fields (func fields)
       "Apply FUNC using FIELDS as the sequence against which to test membership."
       (funcall func #'(lambda (x) (member x fields :test #'string=)) *required-fields*))

     (defun num-required-fields (fields)
       "Count number of required fields found in FIELDS."
       (on-fields #'count-if fields))

     (defun contains-required-fields-p (fields)
       "Return T if all required passport fields were found in FIELDS; NIL otherwise."
       (on-fields #'every fields))

     (defun required-fields-p (line)
       "Return T if line contains all required passport fields (cf. *required-fields*)."
       (contains-required-fields-p (get-fields-from-string line)))

     ;; note: for some reason the last batch was not being processed by loop; we need
     ;; to collect it manually using this extra (slightly ugly) code.
     (defun traverse-collecting-field-names (data)
       (let* ((batch nil)
              (results
               (loop for line in data
                  if (string= line "")
                  collect (get-fields-from-batch batch)
                  and do (setf batch nil)
                  else do (push line batch))))
         (cond (batch (append results (list (get-fields-from-batch batch))))
               (t results))))

          ;;; code for part 2

     (defun lineify (data)
       "Transform DATA so that one passport entry corresponds with one string in the returned list."
       (let* ((batch nil)
              (results
               (loop for line in data
                  if (string= line "")
                  collect (concat-strings (reverse batch))
                  and do (setf batch nil)
                  else do (push line batch))))
         (cond (batch (append results (list (concat-strings (reverse batch)))))
               (t results))))

     (defun whitespacep (c)
       "Return T if C is a space or newline character."
       (or (char= c #\Space) (char= c #\Newline)))

     (defun colonp (c)
       "Return T if C is a colon character."
       (char= c #\:))

     (defun split-string (string &optional (predicate #'whitespacep))
       "Split STRING into multiple strings at the locations determined by
             PREDICATE. Default is to split at spaces/newlines."
       (let ((locs (loop for c across string for i from 0 if (funcall predicate c) collect i)))
         (setf locs (concatenate 'list (list 0) locs (list (length string))))
         (loop for i0 in locs
            for i1 in (cdr locs)
            collect (remove-if predicate (subseq string i0 i1)))))

     (defun parse-field-names-values (line)
       "Return a list of '(key value) lists for each key provided in LINE."
       (mapcar #'(lambda (x) (split-string x #'colonp)) (split-string line)))

     (defun string-number-in-bounds-p (string lower upper)
       "Determine if STRING represents a number that lies between lower and
             upper (inclusive)."
       (let ((n (parse-integer string :junk-allowed t)))
         (when n (<= lower n upper))))

     (defun valid-byr-p (byr)
       "Validate passport birth year IYR."
       (string-number-in-bounds-p byr 1920 2002))

     (defun valid-iyr-p (iyr)
       "Validate passport issue year IYR."
       (string-number-in-bounds-p iyr 2010 2020))

     (defun valid-eyr-p (eyr)
       "Validate passport expiration year EYR."
       (string-number-in-bounds-p eyr 2020 2030))

     (defun valid-hgt-p (hgt)
       "Validate height HEIGHT."
       (cond ((search "cm" hgt) (string-number-in-bounds-p hgt 150 193))
             ((search "in" hgt) (string-number-in-bounds-p hgt 59 76))
             (t nil)))

     (defun valid-hcl-p (hcl)
       "Validate hair colour HCL."
       (let ((hash-pos (position #\# hcl)) )
         (and hash-pos (= hash-pos 0) (= (length hcl) 7)
              (every
               #'(lambda (c) (position c "1234567890abcdef"))
               (subseq hcl 1)))))

     (defun valid-ecl-p (ecl)
       "Validate eye colour ECL."
       (not (null (member ecl (list "amb" "blu" "brn" "gry" "grn" "hzl" "oth") :test #'string=))))

     (defun valid-pid-p (pid)
       "Validate a passport id PID."
       (and (= (length pid) 9) (every #'(lambda (c) (position c "1234567890")) pid)))

     (defun valid-cid-p (cid) "Ignore CID entries and return T." t)

     (defun select-validator (field-name)
       "Select a validator to use according to FIELD-NAME."
       (cond ((string= field-name "byr") #'valid-byr-p)
             ((string= field-name "iyr") #'valid-iyr-p)
             ((string= field-name "eyr") #'valid-eyr-p)
             ((string= field-name "hgt") #'valid-hgt-p)
             ((string= field-name "hcl") #'valid-hcl-p)
             ((string= field-name "ecl") #'valid-ecl-p)
             ((string= field-name "pid") #'valid-pid-p)
             ((string= field-name "cid") #'valid-cid-p)
             (t (format t "Error: could not parse field name") nil)))

     (defun validate-field (field-kv)
       "Validate a passport key-value pair FIELD-KV, a two-element list."
       (funcall (select-validator (car field-kv)) (cadr field-kv)))

     (defun all-field-values-valid-p (line)
       "Validate all provided passport fields in LINE."
       (let ((parsed (parse-field-names-values line)))
         (every #'validate-field parsed)))

     (defun valid-passport-p (line)
       "Determine if LINE corresponds to a valid passport."
       (and (required-fields-p line) (all-field-values-valid-p line)))

     (defun day4-part1 ()
       (count 7 (mapcar #'num-required-fields
                        (traverse-collecting-field-names (read-file "d4.txt")))))

     (defun day4-part2 ()
       (count-if #'valid-passport-p (lineify (read-file "d4.txt"))))

     (verbose1 
       (day4-part1)
       (day4-part2))

   #+end_src

   #+RESULTS:
   : (DAY4-PART1) : -> 245
   : (DAY4-PART2) : -> 133

   
** Day 5
   :PROPERTIES:
   :ID:       D5D0FDF6-828E-400F-8DBF-FFCEF6F96A4E
   :END:

   #+begin_src lisp :exports both :results output :tangle day05.lisp
     (load "my-utils.lisp")

     (defparameter *test-cases* (list "FBFBBFFRLR" "BFFFBBFRRR" "FFFBBBFRRR" "BBFFBBFRLL"))
     (defparameter *test-seat-ids* (list 357 567 119 820))


     (defun front-or-back-p (c)
       (or (char-equal c #\b) (char-equal c #\f)))

     (defun front-or-back (c)
       (cond ((char-equal c #\b) 1)
             ((char-equal c #\f) 0)
             (t nil)))

     (defun left-or-right (c)
       (cond ((char-equal c #\r) 1)
             ((char-equal c #\l) 0)
             (t nil)))

     (defun get-bit-from-character (c)
       (or (front-or-back c) (left-or-right c)))

     (defun get-bit-string (string)
       (loop for c across string collect (get-bit-from-character c)))

     (defun get-integer-from-bit-string (bit-string)
       (apply #'+ (loop for b in (reverse bit-string)
                     for j from 0
                     if (= b 1)
                     collect (expt 2 j))))

     (defun left-right-substr (string)
       (remove-if #'front-or-back-p string))

     (defun front-back-substr (string)
       (remove-if (complement #'front-or-back-p) string))

     (defun get-row-from-string (string)
       (get-integer-from-bit-string (get-bit-string (front-back-substr string))))

     (defun get-column-from-string (string)
       (get-integer-from-bit-string (get-bit-string (left-right-substr string))))

     (defun seat-id (string)
       (+ (* 8 (get-row-from-string string)) (get-column-from-string string)))

     (defun check-test-cases ()
       (when (notevery #'= (mapcar #'seat-id *test-cases*) *test-seat-ids*)
         (format t "Error: test cases did not pass")))

     (check-test-cases)

     (defun day5-part1 (&optional (data (read-file "d5.txt")))
       (loop for line in data maximizing (seat-id line)))

     (defun day5-part2 ()
       (let* ((day5 (read-file "d5.txt"))
              (parsed (mapcar #'seat-id day5))
              (max-id (apply #'max parsed))
              (found (loop for i from 1 to max-id
                        if (and (not (member i parsed))
                                (member (1- i) parsed)
                                (member (1+ i) parsed))
                        collect i)))
         (when (= (length found) 1)
           (car found))))

     (verbose1
       (day5-part1)
       (day5-part2))


   #+end_src

   #+RESULTS:
   : (DAY5-PART1) : -> 894
   : (DAY5-PART2) : -> 579

** Day 6
   :PROPERTIES:
   :ID:       3B91A8DA-B7D5-4114-8E27-B15B10E30F6B
   :END:


   #+begin_src lisp :exports both :results output :tangle day06.lisp
     (load "my-utils.lisp")

     (defparameter *day6* (read-file "d6.txt") "Day 6 puzzle input")
     (defvar *lower*
       (loop with a = (char-code #\a)
             for i below 26
          collect (code-char (+ a i))))

     (ql:quickload 'split-sequence :silent t)

     (defun split-input-by-groups (data)
       "Return a list of lists from DATA, assuming each entry is a string."
       (split-sequence:split-sequence
        0 data :key #'(lambda (x) (length x))))

     (defun output-formatter (string)
       (when string
         (sort (copy-seq (remove-duplicates string)) #'string<)))

     (defun parse-group-any (group)
       "Return GROUP as all found questions with duplicates removed."
       (output-formatter (apply #'concatenate 'string group)))

     (defun parse-group-every (group)
       "Return GROUP as all questions found for every GROUP member."
       (output-formatter
        (cond
          ((= (length group) 1) (car group))
          ((< (length group) 0) nil)
          (t (format nil "~{~A~}"
                     (loop for letter across (car group)
                        if (every #'(lambda (x) (position letter x))
                                  (cdr group))
                        collect letter))))))

     (defun num-questions (data group-parser)
       (apply #'+ (mapcar
                   (lambda (x) (length (funcall group-parser x)))
                   (split-input-by-groups data))))

     (defun day6-part1 ()
       (num-questions *day6* #'parse-group-any))

     (defun day6-part2 ()
       (num-questions *day6* #'parse-group-every))

     (verbose1
       (day6-part1)
       (day6-part2))


   #+end_src

   #+RESULTS:
   : (DAY6-PART1) : -> 6630
   : (DAY6-PART2) : -> 3437

** Day 7
   :PROPERTIES:
   :ID:       8E06349D-A4FD-4E83-B01C-9E8D66F7C4ED
   :END:


   #+begin_src lisp :exports both :results output :tangle day07.lisp
     (load "my-utils.lisp")

     (defparameter *day7* (read-file "d7.txt"))

     ;;;; preprocessing

     (ql:quickload 'split-sequence :silent t)

     (defun split-input-by-groups (data)
       "Return a list of lists from DATA, assuming each entry is a string."
       (split-sequence:split-sequence
        0 data :key #'(lambda (x) (length x))))

     (defun split-parent-child (line)
       (let* ((i0 (search " bags contain " line))
              (i1 (+ i0 14))
              (i2 (1- (length line))))
         (list (subseq line 0 i0) (subseq line i1 i2))))

     (defun no-other-bags-p (children-string)
       (search "no other bags" children-string))

     (defun remove-leading-space (string)
       "docstring"
       (let ((space-pos (position #\Space string)))
         (cond ((and space-pos (= space-pos 0)) (subseq string 1))
               (t string))))

     (defun split-children (children-string)
       "Split a string of all children into a list of each child item"
       (cond ((no-other-bags-p children-string) nil)
             (t (mapcar
                 #'remove-leading-space
                 (split-sequence:split-sequence #\, children-string)))))

     (defun parse-child (child-string)
       (let ((child (split-sequence:split-sequence #\Space child-string)))
         (cons
          (concatenate 'string (cadr child) " " (caddr child))
          (parse-integer (car child)))))

     (defun parse-line (line)
       (let* ((parent-children (split-parent-child line))
              (parent          (car parent-children))
              (children        (split-children (cadr parent-children))))
         (cons (car parent-children)
               (cond (children (mapcar #'parse-child children))
                     (t nil)))))

     (defparameter *data* (mapcar #'parse-line *day7*))

     ;;;; part 1

     (defun mk-contains-colour-p (colour)
       (lambda (entry) (assoc colour (cdr entry) :test #'string=)))

     (defun mk-get-containing-colour (colour)
       (lambda (entry)
         (when (funcall (mk-contains-colour-p colour) entry)
           (car entry))))

     (defun get-containing-colours (data &optional (colour "shiny gold"))
       (remove nil (mapcar (mk-get-containing-colour colour) data)))

     (defun remove-visited (data visited)
       (remove-if #'(lambda (x) (member (car x) visited :test #'string=)) data))

     (defun search-visited (all-visited colours data)
       (let* ((new-data (remove-visited data colours))
              (new-colours
               (mapcan #'(lambda (colour)
                           (get-containing-colours new-data colour))
                       colours)))
         (cond ((and new-colours (> (length new-data) 0))
                (search-visited (append all-visited new-colours) new-colours new-data))
               (t (remove-duplicates all-visited)))))

     ;;;; Part 2

     (defun get-contained-bags (data colour)
       "Return a list of cons cells representing the bag colours and their required
     numbers for a COLOUR bag."
       (cdr (assoc colour data :test #'string=)))

     (defun bag-counter (data item)
       "Return the number of bags + the number of bags inside each of those bags."
       (let ((bag-colour (car item))
             (num-bags   (cdr item)))
         (+ num-bags (* num-bags (count-bags-inside bag-colour data)))))

     (defun count-bags-helper (data contained-bags)
       "Apply BAG-COUNTER to each bag colour in CONTAINED-BAGS and sum the result."
       (apply #'+ (mapcar #'(lambda (item) (bag-counter data item)) contained-bags)))

     (defun count-bags-inside (colour data)
       "Count the number of bags required inside a COLOUR bag."
       (let ((contained-bags (get-contained-bags data colour)))
         (cond (contained-bags (count-bags-helper data contained-bags))
               (t 0))))

     ;;;; final

     (defun day7-part1 ()
       (length (search-visited nil (list "shiny gold") *data*)))

     (defun day7-part2 ()
       (count-bags-inside "shiny gold" *data*))

     (verbose1
       (day7-part1)
       (day7-part2))
   #+end_src

   #+RESULTS:
   : (DAY7-PART1) : -> 177
   : (DAY7-PART2) : -> 34988
   
** Day 08
   :PROPERTIES:
   :ID:       8CDD83AE-801E-483C-86AF-B40592D0E595
   :END:


   #+begin_src lisp :exports both :results output :tangle day08.lisp
     (load "my-utils.lisp")
     (ql:quickload 'split-sequence :silent t)

     (defun parse-instruction (line)
       (destructuring-bind (inst val) (split-sequence:split-sequence #\Space line)
         (cons (read-from-string inst) (parse-integer val))))

     (defparameter *day8* (read-file "d8.txt"))
     (defparameter *accumulator* 0)
     (defparameter *pointer* 0)
     (defparameter *instructions*
       (make-array (length *day8*) :initial-contents (mapcar #'parse-instruction *day8*)))
     (defparameter *running* t)
     (defparameter *visited* nil)

     (defun jmp (&optional (val 1)) (incf *pointer* val))

     (defun acc (val)
       (jmp)
       (incf *accumulator* val))

     (defun nop (&optional val) (jmp))

     (defun get-inst ()
       (cond ((<= 0 *pointer* (1- (length *instructions*)))
              (aref *instructions* *pointer*))
             (t
              (format t "pointer out of bounds with value ~a~%" *pointer*)
              (format t "accumulator has value: ~a.~%" *accumulator*)
              nil)))

     (defun check-visited ()
       (cond ((find *pointer* *visited*)
              (setf *running* nil)
              ,*accumulator*)
             (*running*
              (push *pointer* *visited*)
              nil)))

     (defun eval-instruction (inst)
       "Evaluate INST if non-nil."
       (let ((output-val (check-visited)))
         (cond (output-val output-val)
               (inst (funcall (car inst) (cdr inst)))
               (t nil))))

     (defun reset-runtime ()
       "Reset runtime variables to initial states."
       (setf *accumulator* 0)
       (setf *pointer* 0)
       (setf *visited* nil)
       (setf *running* t))

     ;;;; part 2

     ;;; it stands to reason that we only need to change one of the entries in
     ;;; *visited* with jmp <--> nop. That leaves <=211 possibilities
     (defun get-swap-candidates ()
       "Build list of candidates for part 2 swapping."
       (day08-part1)
       (remove-if-not #'(lambda (x) (or (eql x 'jmp) (eql x 'nop)))
                      ,*visited* :key #'get-inst-type))

     (defun get-inst-symbol (pointer-val)
       "Gets the instruction symbol associated with POINTER-VAL"
       (when (<= 0 pointer-val (1- (length *instructions*)))
         (car (aref *instructions* pointer-val))))

     (defun set-inst-symbol (pointer-val new-inst)
       "Set symbol at POINTER-VAL to NEW-INST."
       (when (or (eql 'jmp new-inst) (eql 'nop new-inst))
         (setf (aref *instructions* pointer-val)
               (cons new-inst (cdr (aref *instructions* pointer-val))))))

     (defun swap-inst-symbol (pointer-val)
       "Swap 'JMP for 'NOP and vice versa at POINTER-VAL (or return NIL)."
       (let ((inst-func (get-inst-symbol pointer-val)))
         (cond ((eql inst-func 'jmp) (set-inst-symbol pointer-val 'nop))
               ((eql inst-func 'nop) (set-inst-symbol pointer-val 'jmp))
               (t nil))))

     (defun eval-if-valid ()
       "Eval instruction associated with *pointer* only if *pointer* is
     valid. Otherwise, stop runtime and return *accumulator* value."
       (cond ((<= 0 *pointer* (1- (length *instructions*)))
              (eval-instruction (get-inst)))
             (t (setf *running* nil)
                ,*accumulator*)))

     (defun execute-swapped-runtime (swap-index)
       (reset-runtime)
       (swap-inst-symbol swap-index)
       (let ((result
              (loop until (not *running*)
                 for x = (eval2-if-valid)
                 finally (return x))))
         (swap-inst-symbol swap-index) ;; swap back!
         result))

     ;;;; final

     (defun day08-part1 ()
       (reset-runtime)
       (loop until (not *running*)
          for x = (eval-instruction (get-inst))
          finally (return x)))


     (defun day08-part2 ()
       (loop for swap-idx in (get-swap-candidates)
          for x = (execute-swapped-runtime swap-idx)
          until x
          finally (return x)))

     (verbose1
       (day08-part1)
       (day08-part2))
   #+end_src

   #+RESULTS:
   : (DAY08-PART1) : -> 1451
   : (DAY08-PART2) : -> 1160
   
** Day 09
   :PROPERTIES:
   :ID:       F755144D-8EBA-4839-A607-8EBCA4249F06
   :END:


   #+begin_src lisp :exports both :results output :tangle day09.lisp
     (load "my-utils.lisp")

     ;;;; def

     (defparameter *day9* (mapcar #'read-from-string (read-file "d9.txt")))
     (defparameter *preamble (subseq *day9* 0 25))
     (defparameter *numbers* (make-array (length *day9*) :initial-contents *day9*))
     (defparameter *cur* 25)
     (defparameter *magic-number* 177777905)

     ;;;; part 1

     (defun range (n &key (start 0))
       (when (and (numberp n) (>= n 0))
         (loop for i from start below n collect i)))

     (defun validate-at-index (index)
       (when (>= (1- (length *numbers*)) index 25)
         (let ((prev (subseq *numbers* (- index 25) index))
               (cur (aref *numbers* index)))
           (loop for a across prev
              do (loop for b across prev
                    if (and (/= b a) (= (+ b a) cur))
                    do (return-from validate-at-index (+ b a)))))))

     ;;;; part 2

     (defun too-small-p (value)
       (< value *magic-number*))

     (defun too-large-p (value)
       (> value *magic-number*))

     (defun get-value (index)
       (aref *numbers* index))

     (defparameter *contig* nil)

     (defun append-right (value) (setf *contig* (append *contig* (list value))))

     (defun pop-left ()
       (let ((ret (car *contig*)))
         (setf *contig* (cdr *contig*))
         ret))

     (defun get-sum ()
       (apply #'+ *contig*))

     (defun search-for-contiguous-sum (&optional (left-idx 0) (right-idx 0))
       "Find a contiguous block of numbers whose sum is equals *MAGIC-NUMBER* (found in Part 1)."
         (cond ((too-small-p (get-sum))              ; if the sum is too small, 
                (append-right (get-value right-idx)) ; add the next number to the block
                (search-for-contiguous-sum left-idx (1+ right-idx))) ; & try again
               ((too-large-p (get-sum)) ; if the sum is too small,
                (pop-left)              ; remove the first number in the block
                (search-for-contiguous-sum (1+ left-idx) right-idx)) ; & try again
               ((>= (length *contig*) 2) ; >= 2 contiguous numbers with desired sum
                (+ (apply #'min *contig*) (apply #'max *contig*))) ; yay!
               (t (append-right (get-value right-idx))     ; keep trying!
                  (search-for-contiguous-sum left-idx (1+ right-idx)))))

     ;;;; final

     (defun day09-part1 ()
       (let ((indices (range (length *numbers*) :start 25)))
         (loop for index in indices
            while (validate-at-index index)
            finally (return (aref *numbers* index)))))

     (defun day09-part2 ()
       (defparameter *contig* nil)
       (search-for-contiguous-sum))

     (verbose1
       (day09-part1)
       (day09-part2))
   #+end_src

   #+RESULTS:
   : (DAY09-PART1) : -> 177777905
   : (DAY09-PART2) : -> 23463012
   

*** Notes

    There is a potential bottleneck in ~APPEND-RIGHT~. Namely, I'm using ~APPEND~ to
    add an element to the end of a list. If the list is long, and/or the
    function is called a lot this could slow things down (because ~APPEND~ has to
    traverse the whole list each time). A way of speeding this up (subject to a
    bit of added complexity) is available in [[https://stackoverflow.com/a/6482598/1456421][this SO post]]. For example,

    #+begin_src lisp :exports both :results output
      (defparameter *contig* nil)
      (defparameter *contig-tail* *contig*)

      ;;; if *contig* is nil it has no tail and so we can't append-right;
      ;;; do a normal PUSH instead.
      (defun append-right--contig (value)
        (cond (*contig-tail*
               (setf (cdr *contig-tail*) (cons value nil))
               (setf *contig-tail* (cdr *contig-tail*)))
              (t (push value *contig*)
                 (setf *contig-tail* *contig*))))

      ;;; APPEND-RIGHT only makes sense when the list is non-nil, else there is no
      ;;; "right" to append to. In this case, start with a usual PUSH and then use
      ;;; APPEND-RIGHT.
      (defun append-right (tail value)
        (when tail
          (setf (cdr tail) (cons value nil))
          (setf tail (cdr tail))
          tail))

      ;;;; Example
      (append-right--contig 0)
      (append-right--contig 1)
      (append-right--contig 2)
      (append-right--contig 3)

      (format t "~{~a~^, ~}~%" *contig*)
      (format t "~{~a~^, ~}~%" *contig-tail*)
    #+end_src

    #+RESULTS:
    : 0, 1, 2, 3
    : 3

** Day 10
   :PROPERTIES:
   :ID:       660CD373-3858-4F42-AEF5-C044B4E5E0E9
   :END:

   #+begin_src lisp :exports both :results output :tangle day10.lisp
     ;; (load "my-utils.lisp")

     (ql:quickload 'split-sequence :silent t)

     (defparameter *day10* (mapcar #'parse-integer (read-file "d10.txt")))
     (defparameter *device-joltage* (+ 3 (apply #'max *day10*)))


     (defun sorted-joltages ()
       (sort (copy-seq *day10*) #'<))

     (defparameter *sorted-joltages*
       (append (list 0) (sorted-joltages) (list *device-joltage*))
       "Includes outlet joltage and device joltage")

     ;;;; Part 1

     (defun diff-func (seq)
       "Compute x1 - x0 where x0 is the first element of SEQ."
       (if (cadr seq)
           (- (cadr seq) (car seq))
           nil))

     (defun diff (seq)
       "Computes the differences between consecutive elements in SEQ."
       (remove nil (maplist #'diff-func seq)))


     ;;;; Part 2

     (defparameter *tribonacci-alist* nil)

     (defun compute-tribonacci--alist (n)
       "Return n-th tribonacci number, computing recursively and using alist
     memoization. Helper function for tribonacci--alist."
       (let ((t-n (+ (tribonacci--alist (- n 1))
                     (tribonacci--alist (- n 2))
                     (tribonacci--alist (- n 3)))))
         (push (cons n t-n) *tribonacci-alist*)
         t-n))

     (defun tribonacci--alist (n)
       "Return the nth tribonacci number using memoization for speed-up."
       (cond
         ((or (not (numberp n)) (< n 0)) (format t "N must be a nonnegative integer.~%"))
         ((<= 0 n 1) 1) ((= n 2) 2)
         ((> n 2)
          (let ((t-n (cdr (assoc n *tribonacci-alist*))))
            (if t-n t-n
                (compute-tribonacci--alist n))))))


     ;;;; final

     (defun day10-part1 ()
       (let ((diffs (diff *sorted-joltages*)))
         (* (count 1 diffs) (count 3 diffs))))

     (defun day10-part2 ()
       "We can view the effect of removing adapters through the diffs. Namely, it's
     equivalent to 'merging' contiguous 1s into 2s or 3s (and no higher, as per the
     problem requirements). It so happens that finding the number of possible
     mergings for a contiguous block of 1s of length n is given by the nth tribonacci
     number. Simply multiply together the tribonacci number associated to each
     contiguous block of 1s to obtain the result.

     Examples are provided for contiguous 1 blocks of length 1 through 5:

     1  [1]: (1)
     2  [2]: (1 1)       (2)
     3  [4]: (1 1 1)     (2 1)     (1 2)      (3)
     4  [7]: (1 1 1 1)   (2 1 1)   (1 2 1)    (1 1 2)   (2 2)     
             (3 1)       (1 3)
     5 [13]: (1 1 1 1 1) (2 1 1 1) (1 2 1 1)  (1 1 2 1) (1 1 1 2)
             (2 2 1)     (2 1 2)   (1 2 2)    (3 1 1)   (1 3 1)   
             (1 1 3)     (3 2)     (2 3)"
       (let* ((diffs (diff *sorted-joltages*))
              (contig-1s (split-sequence:split-sequence 3 diffs))
              (block-lengths (remove 0 (mapcar #'length contig-1s))))
         (apply #'* (mapcar #'tribonacci--alist block-lengths))))

     (verbose1
       (day10-part1)
       (day10-part2))
   #+end_src

   #+RESULTS:
   : (DAY10-PART1) : -> 1980
   : (DAY10-PART2) : -> 4628074479616


   #+begin_src lisp :exports both :results output
     ;;; hash table implementation of the tribonacci function, just for fun.

     (defparameter *tribonacci-hash* (make-hash-table))

     (defun compute-tribonacci--hash (n)
       "Return n-th tribonacci number, computing recursively and using hash table
     memoization. Helper function for tribonacci--hash."
       (setf (gethash n *tribonacci-hash*)
             (+ (tribonacci--hash (- n 1))
                (tribonacci--hash (- n 2))
                (tribonacci--hash (- n 3)))))

     (defun tribonacci--hash (n)
       "Return the nth tribonacci number using memoization for speed-up."
       (when n
         (cond
           ((or (not (numberp n)) (< n 0)) (format t "N must be a nonnegative integer.~%"))
           ((<= 0 n 1) 1) ((= n 2) 2)
           ((> n 2)
            (let ((t-n (gethash n *tribonacci-hash*)))
              (if t-n t-n (compute-tribonacci--hash n)))))))
   #+end_src

** Day 11
   :PROPERTIES:
   :ID:       6C47E0CA-9A6B-436A-A5EC-11A1BA478206
   :END:

   #+begin_src lisp :exports both :results output :tangle day11.lisp
     (defparameter *day11* (read-file "d11.txt"))
     (defparameter *m* (length *day11*))
     (defparameter *n* (length (car *day11*)))
     (defparameter *seats* (make-array (list *m* *n*)))

     (defun seating-char->num (elem)
       "Convert ELEM from numerical to character representation.
         0 <-> #\L
         1 <-> #\#
        -1 <-> #\. "
       (cond ((char= elem #\L) 0)
             ((char= elem #\#) 1)
             ((char= elem #\.) -1)
             (t nil)))

     (defun seating-num->char (elem)
       "Convert ELEM from character to numerical representation.
         0 <-> #\L
         1 <-> #\#
        -1 <-> #\. "
       (cond ((= elem 0) #\L)
             ((= elem 1) #\#)
             ((= elem -1) #\.)
             (t nil)))

     (defun print-seating (seating)
       "Print a SEATING that has been converted to 'num' type."
       (let ((converted (mapcar #'(lambda (row) (mapcar #'seating-num->char row)) seating)))
         (format t "~{~{~a~}~%~}~%" converted)))

     (defun print-seats-arr ()
       (loop for i from 0 below *m*
          do (progn
               (loop for j from 0 below *n*
                  do (format t "~a" (seating-num->char (aref *seats* i j))))
               (fresh-line)))
       (format t "~%~%"))

     (defun initialize-seating-arr ()
       "Set the elements of *SEATS* to their initial values."
       (loop for row in *day11* for i from 0
          do (loop for elem across row for j from 0
                do (setf (aref *seats* i j) (seating-char->num elem)))))

     ;;;; Part 1


     (defun get-elem (idx)
       "Return the element of *SEATS* given by IDX, which is a CONS cell with
        format (ROW . COLUMN)."
       (aref *seats* (car idx) (cdr idx)))

     (defmacro test-elem (idx val)
       "Boilerplate for testing whether the IDX element of *SEATS* has value VAL."
       `(= (get-elem ,idx) ,val))

     (defun empty-seat-p (idx) (test-elem idx 0))

     (defun filled-seat-p (idx) (test-elem idx 1))

     (defun seat-p (idx)
       "Predicate returning T if element IDX is a seat."
       (or (empty-seat-p idx) (filled-seat-p idx)))

     (defun floor-p (idx) (test-elem idx -1))

     (defun neighbour-relative-positions ()
       "Helper function returning the <=8 neighbouring indices about an index."
       (apply #'append
              (loop for i from -1 to 1
                 collect (loop for j from -1 to 1
                            unless (and (= i 0) (= j 0))
                            collect (cons i j)))))

     (defun idx-oob-p (idx)
       "Checks if index IDX is 'out of bounds'. IDX has the form (ROW . COLUMN),
        where 0 <= ROW < *m* and 0 <= COLUM < *n*."
       (or (or (< (car idx) 0) (>= (car idx) *m*))
           (or (< (cdr idx) 0) (>= (cdr idx) *n*))))

     (defun idx+ (idx1 idx2)
       "Add two indices IDX1 and IDX2."
       (cons (+ (car idx1) (car idx2))
             (+ (cdr idx1) (cdr idx2))))

     (defun get-neighbouring-indices (idx)
       "Get indices representing neighbours of IDX."
       (remove-if
        #'idx-oob-p
        (mapcar #'(lambda (ij) (idx+ idx ij))
                (neighbour-relative-positions))))

     (defun get-neighbouring-values (idx)
       "Get values stored in neighbouring indices of IDX."
       (mapcar #'get-elem (get-neighbouring-indices idx)))

     (defun num-neighbours-occupied (idx)
       "Count number of neighbours that are occupied seats."
       (count 1 (get-neighbouring-values idx)))

     (defun set-elem (idx value)
       "Set element IDX of *SEATS* to VALUE."
       (setf (aref *seats* (car idx) (cdr idx)) value))

     (defun update-seat (idx)
       "Apply seat update rule to element IDX of *SEATS*."
       (cond ((and (empty-seat-p idx) (= 0 (num-neighbours-occupied idx))) 1)
             ((and (filled-seat-p idx) (<= 4 (num-neighbours-occupied idx))) 0)
             (t (get-elem idx))))

     (defun get-new-seating (&optional (seating-update-func #'update-seat))
       "Determine new seating by applying update rules simultaneously to all elements
        of *SEATS*."
       (loop for i from 0 below *m*
          collect (loop for j from 0 below *n*
                     collect (funcall seating-update-func (cons i j)))))

     (defun update-seating (new-seating)
       "Update seating arrangement by setting *SEATS* to be the result of
        GET-NEW-SEATING."
         (loop for row in new-seating
            for i from 0
            do (loop for elem in row
                  for j from 0
                  do (set-elem (cons i j) elem))))

     (defun seating= (new-seating)
       "Compare NEW-SEATING to *SEATS*, returning T if all elements are equal."
       (loop for new-row in new-seating
          for i from 0
          do (loop for new-elem in new-row
                for j from 0
                do (when (/= new-elem (get-elem (cons i j))) (return-from seating= nil))))
       t)

     (defun count-occupied ()
       "Count number of occupied seats in *SEATS*."
       (loop for i from 0 below *m*
          summing (loop for j from 0 below *n*
                     counting (= (get-elem (cons i j)) 1))))


     ;;;; Part 2

     (defun idx* (idx alpha)
       "Multiply IDX by a scalar ALPHA."
       (cons (* (car idx) alpha) (* (cdr idx) alpha)))

     (defun relative-neighbour (idx slope r)
       "Get a 'neighbour' along SLOPE from IDX at l1-radius R."
       (idx+ idx (idx* slope r)))

     (defun first-chair-along-ray (idx slope)
       "Return chair status (i.e. 0 or 1) for first chair found along a ray with
        slope SLOPE beginning from IDX (not including IDX). Return -1 if no chair
        found."
       (loop for r from 1
          for neighbour = (relative-neighbour idx slope r)
          until (idx-oob-p neighbour)
          if (seat-p neighbour)
          do (return-from first-chair-along-ray (get-elem neighbour))
          finally (return -1)))

     (defun occupancy-in-lines-of-sight (idx)
       "Return list of chair occupancy along all <=8 lines of sight."
       (mapcar
        #'(lambda (slope) (first-chair-along-ray idx slope))
        (neighbour-relative-positions)))

     (defun num-visible-occupancy (idx)
       "Count number of visibly occupied chairs along all <= 8 lines of sight."
       (count 1 (occupancy-in-lines-of-sight idx)))

     (defun no-visible-occupancy-p (idx)
       (= 0 (num-visible-occupancy idx)))

     (defun update-seat2 (idx)
       "Apply 2nd seat update rule to element IDX of *SEATS*."
       (cond ((and (empty-seat-p idx) (no-visible-occupancy-p idx)) 1)
             ((and (filled-seat-p idx) (<= 5 (num-visible-occupancy idx))) 0)
             (t (get-elem idx))))

     (defun occupancy-los-array ()
       "For debugging. Make an array containing the number of visibly occupied chairs
     from each index in *SEATS*."
       (loop for i from 0 below *m*
          collect (loop for j from 0 below *n*
                     collect (num-visible-occupancy (cons i j)))))

     (defun print-occupancy-los-array ()
       "For debugging. Print an array containing the number of visibly occupied
     chairs from each index in *SEATS*."
       (let ((occupancy-arr (occupancy-los-array)))
         (format t "Occupancy-LOS-array:~%~{~{~a~}~%~}~%" occupancy-arr)))

     ;;;; final

     (defun day11-part1 ()
       (initialize-seating-arr)
       (let ((new-seating (get-new-seating)))
         (loop until (seating= new-seating)
            do (progn
                 (update-seating new-seating)
                 (setf new-seating (get-new-seating)))
            finally (return (count-occupied)))))

     (defun day11-part2 ()
       (initialize-seating-arr)
       (let ((new-seating (get-new-seating #'update-seat2)))
         (loop until (seating= new-seating)
            do (progn
                 (update-seating new-seating)
                 (setf new-seating (get-new-seating #'update-seat2)))
            finally (return (count-occupied)))))

     (verbose1
       (day11-part1)
       (day11-part2))
   #+end_src

   #+RESULTS:
   : (DAY11-PART1) : -> 2113
   : (DAY11-PART2) : -> 1865
   

** Day 12
   :PROPERTIES:
   :ID:       72A5D375-16BC-4C15-AFF6-EB2E885D129A
   :END:


   #+begin_src lisp :exports both :results output :tangle day12.lisp
     (defparameter *day12* (read-file "d12.txt"))
     (defparameter *theta* 0 "Ship angle (initially aligned with x axis)")
     (defparameter *x* 0 "Ship x position")
     (defparameter *y* 0 "Ship y position")

     (defun re-initialize-parms ()
       (setf *theta* 0)
       (setf *x* 0)
       (setf *y* 0))

     (defun deg->rad (degrees)
       (* degrees (/ pi 180)))

     (defun rotate (angle) (setf *theta* (- (mod (+ 180 (+ *theta* angle)) 360) 180)))
     (defun rotate-right (angle) (rotate (- angle)))
     (defun rotate-left (angle) (rotate angle))

     (defun move-forward (distance)
       (incf *x* (* (cos (deg->rad *theta*)) distance))
       (incf *y* (* (sin (deg->rad *theta*)) distance)))

     (defun move-north (distance) (incf *y* distance))
     (defun move-south (distance) (incf *y* (- distance)))
     (defun move-east (distance) (incf *x* distance))
     (defun move-west (distance) (incf *x* (- distance)))

     (defun search-for (letter string)
       (some #'(lambda (x) (char-equal x letter)) string))

     (defun parse-action (line)
       (cond ((search-for #\r line) #'rotate-right)
             ((search-for #\l line) #'rotate-left)
             ((search-for #\n line) #'move-north)
             ((search-for #\s line) #'move-south)
             ((search-for #\e line) #'move-east)
             ((search-for #\w line) #'move-west)
             ((search-for #\f line) #'move-forward)
             (t nil)))


     (defun parse-distance (line)
       (parse-integer (subseq line 1)))

     (defun eval-line (line &optional (action-parser #'parse-action))
       (let ((action (funcall action-parser line)))
         (when action
           (funcall action (parse-distance line)))))

     (defun manhattan-dist ()
       (floor (+ (abs *x*) (abs *y*))))


     ;;;; Part 2

     (defparameter *wp-x* 10 "way-point x position")
     (defparameter *wp-y* 1 "way-point y position")

     (defun waypoint-radius ()
       (sqrt (+ (expt *wp-x* 2) (expt *wp-y* 2))))

     (defun waypoint-angle ()
       (let ((principal (atan (/ *wp-y* *wp-x*))))
         (cond ((and (< *wp-x* 0) (< *wp-y* 0)) (- principal pi))
               ((< *wp-x* 0) (+ principal pi))
               (t principal))))

     (defun rotate-waypoint-right (angle)
       (let ((radius (waypoint-radius))
             (theta (- (waypoint-angle) (deg->rad angle))))
         (setf *wp-x* (* radius (cos theta)))
         (setf *wp-y* (* radius (sin theta)))))

     (defun rotate-waypoint-left (angle)
       (rotate-waypoint-right (- angle)))

     (defun move-waypoint-north (distance) (incf *wp-y* distance))
     (defun move-waypoint-south (distance) (incf *wp-y* (- distance)))
     (defun move-waypoint-east (distance) (incf *wp-x* distance))
     (defun move-waypoint-west (distance) (incf *wp-x* (- distance)))
     (defun move-waypointward (distance)
       (incf *x* (* distance *wp-x*))
       (incf *y* (* distance *wp-y*)))

     (defun parse-action2 (line)
       (cond ((search-for #\r line) #'rotate-waypoint-right)
             ((search-for #\l line) #'rotate-waypoint-left)
             ((search-for #\n line) #'move-waypoint-north)
             ((search-for #\s line) #'move-waypoint-south)
             ((search-for #\e line) #'move-waypoint-east)
             ((search-for #\w line) #'move-waypoint-west)
             ((search-for #\f line) #'move-waypointward)
             (t nil)))

     ;;;; final

     (defun day12-part1 ()
       (loop for line in *day12*
          do (eval-line line)
          finally (return (manhattan-dist))))

     (defun day12-part2 ()
       (re-initialize-parms)
       (loop for line in *day12*
          do (eval-line line #'parse-action2)
          finally (return (manhattan-dist))))

     (verbose1
       (day12-part1)
       (day12-part2))
   #+end_src

   #+RESULTS:
   : (DAY12-PART1) : -> 1319
   : (DAY12-PART2) : -> 62434
   
** Day 13
   :PROPERTIES:
   :ID:       9835D616-A57F-4957-9F60-3282E6300270
   :END:

   #+begin_src lisp :exports both :results output :tangle day13.lisp
     (ql:quickload 'split-sequence :silent t)

     (defparameter *day13* (read-file "d13.txt"))
     (defparameter *my-arr-time* (parse-integer (car *day13*)))

     (let ((bus-nums (mapcar
                      #'(lambda (x) (parse-integer x :junk-allowed t))
                      (split-sequence:split-sequence #\, (cadr *day13*)))))
       (defparameter *bus-numbers* (remove nil bus-nums))
       (defparameter *bus-positions*
         (loop for elem in bus-nums for i from 0
            if elem collect i)))

     (defun waiting-time (my-arr-time bus-loop-duration)
       "Find amount of time you need to wait for the bus to take you to the airport."
       (- bus-loop-duration (mod my-arr-time bus-loop-duration)))

     (defun argmin-helper (func &optional x y)
       "Return X if (FUNC X) < (FUNC Y) else return Y."
       (cond ((and x y)
              (let ((fx (funcall func x))
                    (fy (funcall func y)))
                (if (> fx fy) y x)))
             (x x)))

     (defun argmin (func &rest args)
       "Return the element of ARGS that minimizes FUNC."
       (cond ((<= (length args) 2) (apply #'argmin-helper func args))
             (t (destructuring-bind (x y &rest rest) args
                  (apply #'argmin func (cons (argmin-helper func x y) rest))))))


     ;;;; Part 2

     (defun egcd (a b)
       "Extended Euclidean algorithm. Return (r s t) where r is remainder and (s t)
       are such that s*a + t*b = r."
       ;; update rule looks like r_{i+1} = q*r_{i+1} - r_{i}
       (do ((r (cons b a) (cons (- (cdr r) (* (car r) q)) (car r))) ; (new-r old-r)
            (s (cons 0 1) (cons (- (cdr s) (* (car s) q)) (car s))) ; (new-s old-s)
            (u (cons 1 0) (cons (- (cdr u) (* (car u) q)) (car u)))); (new-t old-t)
           ;; iterate until r_{I+1} = 0; return (r_{I} s_{I} t_{I})
           ((zerop (car r)) (values (cdr r) (cdr s) (cdr u)))
         ;; update quotient q
         (setf q (floor (cdr r) (car r)))))

     (defun invmod (a m)
       "Return the inverse of a-inverse(mod m). Throw error if (a m) not co-prime."
       (multiple-value-bind (r s u) (egcd a m)
         (unless (= 1 r) (error "invmod: Values ~a and ~a are not co-prime." a m))
         s))

     (mapcar #'cdr (list '(1 . 2) '(3 . 4)))

     (defun chinese-remainder (am)
       "am is a list of cons cells where the integers are the cars and the moduli are
       the cdrs."
       (loop for (a . m) in am
          with prod-m = (apply #'* (mapcar #'cdr am))
          and result = 0
          for yi = (/ prod-m m)
          for zi = (invmod yi m)
          finally (return (mod result prod-m))
          do (incf result (* a yi zi))))

     ;;;; final

     (defun day13-part1 ()
       (let ((best-bus-number
              (apply
               #'argmin
               #'(lambda (bus-number)
                   (waiting-time *my-arr-time* bus-number))
               ,*bus-numbers*)))
         (* best-bus-number (waiting-time *my-arr-time* best-bus-number))))


     (defun day13-part2 ()
       "Goal is to find tstamp + offset_i \cong 0(mod bus-number_i). Compute this
        using the chinese remainder theorem with integers a given by the negative of
        the bus-positions, and the moduli m given as the bus numbers (which are all
        prime)."
       (chinese-remainder (pairlis (mapcar #'- *bus-positions*) *bus-numbers*)))

     (verbose1
       (day13-part1)
       (day13-part2))
   #+end_src

   #+RESULTS:
   : (DAY13-PART1) : -> 261
   : (DAY13-PART2) : -> 807435693182510

** Day 14
   :PROPERTIES:
   :ID:       E0B60C09-12A7-4E6C-BB88-85B234BE1B18
   :END:

   #+begin_src lisp :exports both :results output :tangle day14.lisp
     (ql:quickload 'split-sequence :silent t)

     (defparameter *day14* (read-file "d14.txt"))


     ;;;; Part 1

     (defparameter *zero-mask* nil)
     (defparameter *one-mask* nil)

     (defun get-mask (line)
       (let ((split-line (split-sequence:split-sequence #\Space line)))
         (when (string= (car split-line) "mask")
           (car (last split-line)))))

     (defun set-mask (mask-string)
       (when mask-string
         (setf *zero-mask* 0)
         (setf *one-mask* 0)
         (loop for c across mask-string
            for i from 35 downto 0
            if (char= c #\0)
            do (incf *zero-mask* (expt 2 i))
            if (char= c #\1)
            do (incf *one-mask* (expt 2 i))
            finally (return (values *zero-mask* *one-mask*)))))

     (defun update-mask (line)
       (let ((mask-string (get-mask line)))
         (set-mask mask-string)))

     (defun parse-mem-line (line)
       (if (get-mask line) (cons nil nil)
           (let* ((address-value (split-sequence:split-sequence #\= line))
                  (address (remove-if-not #'digit-char-p (car address-value)))
                  (value (remove-if-not #'digit-char-p (cadr address-value))))
             (cons (parse-integer address) (parse-integer value)))))

     (defun apply-bitmask (value)
       (logior *one-mask* (logand (lognot *zero-mask*) value)))

     (defun eval-mem-line (line)
       (destructuring-bind (address . value) (parse-mem-line line)
         (when (and address value)
           (cons address (apply-bitmask value)))))


     ;;;; Part 2

     (defparameter *1s-mask* 0) ; to force bits to 1
     (defparameter *0s-mask* 0) ; to keep the values that remain unchanged
     (defparameter *floating-mask-bits* nil)
     (defparameter *floating-masks* nil)


     (defun powerset (s)
       "See https://rosettacode.org/wiki/Power_set#Common_Lisp"
       (if s (mapcan (lambda (x) (list (cons (car s) x) x)) 
                     (powerset (cdr s))) 
           '(())))

     (defun set-floating-masks-from-bits ()
       (loop for bit-set in (powerset *floating-mask-bits*)
          do (push (loop for b in bit-set summing (expt 2 b)) *floating-masks*)))

     (defun set-floating-mask (mask-string)
       (when mask-string
         (setf *1s-mask* 0)
         (setf *0s-mask* 0)
         (setf *floating-mask-bits* nil)
         (setf *floating-masks* nil)
         (loop for c across mask-string
            for i from 35 downto 0
            if (char= c #\X)
            do (push i *floating-mask-bits*)
            if (char= c #\0)
            do (incf *0s-mask* (expt 2 i))
            if (char= c #\1)
            do (incf *1s-mask* (expt 2 i))
            finally (set-floating-masks-from-bits))))

     (defun update-masks2 (line)
       "Update masks for floating bit mask challenge (part 2)."
       (let ((mask-string (get-mask line)))
         (set-floating-mask mask-string)))

     (defun mem-addr-decode (address)
       (when (and address *floating-masks*)
         (let ((root-address (logior *1s-mask* (logand address *0s-mask*))))
           (mapcar #'(lambda (x) (logior root-address x)) *floating-masks*))))

     (defun eval-mem-line2 (line)
       (destructuring-bind (address . value) (parse-mem-line line)
         (when (and address value)
           (mapcar #'(lambda (addr) (cons addr value)) (mem-addr-decode address)))))

     ;;;; final

     (defun day14-part1 ()
       (loop
          for (addr . value) in
            (remove-duplicates
             (loop for line in *day14*
                for addr-val = (eval-mem-line line)
                do (update-mask line)
                if (numberp (car addr-val))
                collect addr-val)
             :key #'car)
          summing value))

     (defun day14-part2 ()
       (loop
          for key being the hash-keys of
            (loop with my-memory = (make-hash-table :size 1000)
               for line in *day14*
               for addr-val-list = (eval-mem-line2 line)
               do (update-masks2 line)
               if addr-val-list
               do (loop for (addr . val) in addr-val-list
                     do (setf (gethash addr my-memory) val))
               finally (return my-memory))
          using (hash-value value)
          summing value))

     (verbose1
       (day14-part1)
       (day14-part2))
   #+end_src

   #+RESULTS:
   : (DAY14-PART1) : -> 6317049172545
   : (DAY14-PART2) : -> 3434009980379
   

** Day 15
   :PROPERTIES:
   :ID:       1C5F03F7-B9E3-4B50-BBEA-D17F63A7E7A3
   :END:

   #+begin_src lisp :exports both :results output :tangle day15.lisp
     (defparameter *day15* (list 1 12 0 20 8 16))
     (defparameter *last-number* 16 "The last number that was spoken")
     (defparameter *turn* 6 "The last turn number")
     (defparameter *alist* nil)

     (defun re-initialize ()
       (setf *alist* nil)
       (setf *last-number* 16)
       (setf *turn* 6)
       (loop for key in *day15* for value from 1
          do (push (cons key value) *alist*)))

     (defun empty-alist ()
       (setf *alist* nil))

     (defun cdr- (c1 c2)
       (if (and c1 c2)
           (- (cdr c1) (cdr c2))
           0))

     (defun next-number ()
       (cdr- (assoc *last-number* *alist*)
             (assoc *last-number* (cdr *alist*))))

     (defun update-alist ()
       (incf *turn*)
       (push (cons (next-number) *turn*) *alist*)
       (setf *last-number* (caar *alist*))
       (car *alist*))

     ;;;; Part 2

     ;;; alists were fine for part 1, but part 2 is too big and we must use a hash
     ;;; table afterall.

     (defparameter *hashmap* (make-hash-table :size 10000))
     (defparameter *cur* (cons 16 6) "current number")

     (defun get-hashkeys ()
       (let ((keys nil))
         (maphash #'(lambda (k v) (push k keys)) *hashmap*)
         keys))

     (defun empty-hashmap ()
       (let ((keys (get-hashkeys)))
         (dolist (k keys)
           (remhash k *hashmap*))))

     (defmacro set-hash (key value)
       `(setf (gethash ,key *hashmap*) ,value))

     (defun re-initialize2 ()
       (setf *cur* (cons 16 6))
       (setf *turn* 6)
       (empty-hashmap)
       (loop for key in *day15* for value from 1
          do (set-hash key value)))

     (defun print-hashkeys ()
       (maphash #'(lambda (k v) (format t "k: ~a v: ~a~%" k v)) *hashmap*)
       (format t "----~%"))

     (defun next-number ()
       (let ((last-seen (gethash (car *cur*) *hashmap*)))
         (if last-seen
             (- (cdr *cur*) last-seen)
             0)))

     (defun update-hash ()
       (let ((tmp-cur *cur*))
         (setf *cur* (cons (next-number) (incf *turn*)))
         (set-hash (car tmp-cur) (cdr tmp-cur))))

     ;;;; final

     (defun day15-part1 (&optional (end-num 2020))
       (re-initialize)
       (loop until (>= *turn* end-num)
          do (update-alist)
          finally (return (rassoc end-num *alist*))))

     (defun day15-part2 ()
       (re-initialize2)
       (loop until (= (cdr *cur*) 30000000)
          do (update-hash)
          finally (return *cur*)))

     (verbose1
       (day15-part1)
       (day15-part2))

   #+end_src

   #+RESULTS:
   : (DAY15-PART1) : -> (273 . 2020)
   : (DAY15-PART2) : -> (47205 . 30000000)
   

** Day 16
   :PROPERTIES:
   :ID:       35D53489-4931-488A-9CF0-19596E8A8B95
   :END:


   #+begin_src lisp :exports both :results output :tangle day16.lisp
     (ql:quickload 'split-sequence :silent t)

     (defparameter *day16* (read-file "d16.txt"))

     (defparameter *ticket-field-rules*
       (loop for line in *day16*
          for line-length = (length line)
          for i from 0
          until (zerop line-length)
          if (not (zerop line-length))
          collect line))

     (defun parse-ticket (ticket)
       (mapcar #'parse-integer (split-sequence:split-sequence #\, ticket)))

     (defparameter *your-ticket*
       (parse-ticket
        (cadr
         (loop for line in *day16*
            for line-length = (length line)
            with read-flag = nil
            if (and read-flag (> line-length 0))
            collect line
            if (zerop line-length)
            do (setf read-flag (not read-flag))
            until (search "nearby ticket" line)))))

     (defparameter *nearby-tickets*
       (mapcar #'parse-ticket
               (loop for line in *day16*
                  with read-flag = nil
                  if read-flag
                  collect line
                  if (search "nearby ticket" line)
                  do (setf read-flag t))))


     (defun to-cons (list)
       "Take a two element list '(A B) and return a dotted pair (A . B)."
       (when (eql 2 (length list))
         (setf (cdr list) (cadr list)))
       list)

     (defun valid-range (ticket-field-rule)
       (let* ((range-string (cadr (split-sequence:split-sequence #\: ticket-field-rule)))
              (ranges-list (split-sequence:split-sequence #\Space range-string))
              (range-pairs
               (remove-if
                #'(lambda (x) (or (zerop (length x)) (not (find #\- x))))
                ranges-list)))
         (mapcar #'(lambda (x)
                     (to-cons (mapcar #'parse-integer
                                      (split-sequence:split-sequence #\- x))))
                 range-pairs)))

     (defun dotted-pair-p (list)
       "Return T if list is a dotted pair CONS cell (A . B) and NIL otherwise."
       (and (listp list) (not (listp (cdr list)))))

     (defun interval-union (i1 i2)
       "I1 and I2 are CONS cells with (CAR I1) < (CAR I2)."
       (cond ((null i1) i2)
             ((null i2) i1)
             ((<= (cdr i2) (cdr i1)) i1) ; i1lo <= i2lo <= i2up <= i1up
             ((<= (car i2) (cdr i1)) (cons (car i1) (cdr i2))) ; i1lo <= i2lo <= i1up <= i2up
             (t (list i1 i2))))

     (defun unionize (i1 i2 &rest intervals)
       "Simplify a collection of intervals into a union (i.e. LIST) of
        non-overlapping intervals (i.e. CONS cells)."
       (let ((i12 (interval-union i1 i2)))
         (cond ((null intervals) i12)
               ((dotted-pair-p i12)
                (push i12 intervals)
                (apply #'unionize intervals))
               (t
                (push (cadr i12) intervals)
                (append (list (car i12)) (apply #'unionize intervals))))))

     (defparameter *valid-range*
       (apply #'unionize
              (sort
               (apply #'append (mapcar #'valid-range *ticket-field-rules*))
               #'< :key #'car))
       "An interval (i.e. CONS cell) whose CAR is the lower end of the valid range,
       and CDR is the upper end of the valid range (as defined by part 1 of this
       challenge).")

     (defun in-interval (value interval)
       "Return T if value is in the interval INTERVAL."
       (when (dotted-pair-p interval)
         (<= (car interval) value (cdr interval))))

     (defun in-uoi (value uoi)
       "Return T if VALUE is in the union of intervals UOI."
       (cond ((dotted-pair-p uoi) (in-interval value uoi))
             ((listp uoi) (some #'(lambda (x) (in-interval value x)) uoi))
             (t (error "in-range: Unexpected condition reached; *valid-range* is not
             a list or dotted pair"))))

     (defun in-range (value)
       (in-uoi value *valid-range*))


     ;;;; Part 2

     (defparameter *valid-tickets*
       (remove-if
        #'(lambda (ticket)
            (notevery #'(lambda (value) (in-range value))
                      ticket))
        ,*nearby-tickets*))
     (push *your-ticket* *valid-tickets*) ;; 191 tickets



     (defun get-ticket-field-ranges ()
       (mapcar #'valid-range *ticket-field-rules*))

     (defun possible-slots (ticket-field-range)
       "Compute the possible slots for the ticket-field-range. Return an array of T
        and NIL where an index has value T that index is a possible slot for the ticket
        field."
         (loop for ticket in *valid-tickets*
            with memb-arr = (make-array (length *your-ticket*) :initial-element t)
            do (loop
                  for value in ticket
                  for i from 0
                  if (not (in-uoi value ticket-field-range))
                  do (setf (aref memb-arr i) nil))
            finally (return memb-arr)))

     (defun possible-slot-array ()
       "A column index j corresponds to a slot on the ticket; a row index i
       corresponds with a ticket field."
       (make-array '(20 20)
                   :initial-contents
                   (mapcar #'possible-slots (get-ticket-field-ranges))))

     (defun possible-slot-counts (arr)
       "Returns a list where each element corresponds to the number of ticket fields
       that could be valid in that slot."
       (loop for j from 0 below 20
          collect (loop for i from 0 below 20
                     counting (aref arr i j))))

     (defun get-row-for-slot-count (n exclude)
       "Retrieve the row of (POSSIBLE-SLOT-ARRAY) where (POSSIBLE-SLOT-COUNTS) is
       N. Use EXCLUDE to exclude the TICKET-FIELD-INDEX values returned for lower
       values of N."
       (let* ((arr (possible-slot-array))
              (pslot-counts (possible-slot-counts arr))
              (search-column (loop
                                for c in pslot-counts
                                for i from 0
                                until (eql c n)
                                finally (return i))))
         (car
          (loop for i from 0 below 20
             if (and (aref arr i search-column) (not (find i exclude)))
             collect (list :ticket-field-index i :slot-number search-column)))))

     (defun departure-slots ()
       "The departure ticket field indices are the first six. So we need the slot
       numbers corresponding to ticket-field-index 0 through 5."
       (loop for n from 1 to 20
          with exclude = nil
          for result = (get-row-for-slot-count n exclude)
          do (push (getf result :ticket-field-index) exclude)
          if (<= (getf result :ticket-field-index) 5)
          collect (getf result :slot-number)))

     (defun get-your-ticket-value-at (slot)
       (nth slot *your-ticket*))


     ;;;; final

     (defun day16-part1 ()
       (apply
        #'+
        (apply
         #'append
         (remove
          nil
          (mapcar
           #'(lambda (ticket)
               (remove-if
                #'(lambda (value)
                    (in-range value))
                ticket))
           ,*nearby-tickets*)))))

     (defun day16-part2 ()
       (apply #'* (mapcar #'get-your-ticket-value-at (departure-slots))))

     (verbose1
       (day16-part1)
       (day16-part2))
   #+end_src

   #+RESULTS:
   : (DAY16-PART1) : -> 25895
   : (DAY16-PART2) : -> 5865723727753

** Day 17
   :PROPERTIES:
   :ID:       630D7CAB-D991-4C25-B29E-413F5BE1E923
   :END:

   #+begin_src lisp :exports both :results output :tangle day17.lisp
     (defparameter *day17* (read-file "d17.txt"))
     (defparameter *state* (make-hash-table :test 'equalp))

     (defun initialize (&optional (dim 3))
       (labels
           ((clear-state ()
              (loop for key being the hash-keys of *state*
                 do (remhash key *state*)))
            (cube-status (c)
              (cond ((char= c #\#) 1)
                    ((char= c #\.) 0)
                    (t nil)))
            (repeat (item times) (loop repeat times collect item))
            (indexer (dim &rest indices)
              (concatenate 'list indices (repeat 0 (- dim 2))))
            (parse-input ()
              (loop for line in *day17*
                 for i from 0
                 do (loop for c across line
                       for j from 0
                       do (setf (gethash (indexer dim i j) *state*)
                                (cube-status c))))))
         (clear-state)
         (parse-input)))

     (defun get-state (idx)
       (gethash idx *state*))

     (defun initialize-state (idx)
       (setf (gethash idx *state*) 0))

     (defun uninitialized-p (idx)
       (null (gethash idx *state*)))

     (defun active-p (idx)
       (eql 1 (gethash idx *state*)))

     (defun print-cubes ()
       (maphash #'(lambda (k v)
                  (format t "k: ")
                  (princ k)
                  (format t " v: ~a~%" v))
                ,*state*))

     (defun gensym-vector (len)
       "Create a vector of length LEN of generated symbols."
       (map 'vector #'(lambda (x) (gensym)) (loop for i from 0 below len collect i)))

     (defmacro get-state-bounds (&optional (state-var *state*) (dim 3))
       "Get min and max indices for *state*."
       (let ((bounds-vars (gensym-vector (* 2 dim))))
         `(loop for idx being the hash-keys of ,state-var
             using (hash-value state)
             if (not (null state))
               ,@(loop for d from 0 below dim
                    append
                      `(minimize (nth ,d idx) into ,(aref bounds-vars (* 2 d)))
                    append
                      `(maximize (nth ,d idx) into ,(aref bounds-vars (1+ (* 2 d)))))
             finally (return (values
                              ,@(loop for i from 0 below dim
                                   collect `(cons ,(aref bounds-vars (* 2 i))
                                                  ,(aref bounds-vars (1+ (* 2 i))))))))))

     (defun pprint-state ()
       "Only works with 3 dimensions right now."
       (multiple-value-bind (ib jb kb) (get-state-bounds)
         (loop for k from (car kb) to (cdr kb)
            collect (loop for i from (car ib) to (cdr ib)
                       collect (loop for j from (car jb) to (cdr jb)
                                  if (eql 1 (get-state (list i j k)))
                                  collect #\# into result
                                  else collect #\. into result
                                  finally (return (concatenate 'string result)))
                         into result
                       finally (return (format nil "~{~a~^~%~}~%" result)))
            into result
            finally (format t "~{~a~^~%~}~%" result))))

     (defmacro relative-neighbours (dim)
       "Compute all relative neighbours in dimension DIM."
       (let* ((indices (gensym-vector dim))
              (result `(for item = (list ,@(map 'list #'identity indices))
                            unless (every #'zerop item)
                            collect item)))
         (loop for d from 0 below dim
            if (= d 0)
            do (setf result `(loop for ,(aref indices (1- (- dim d)))
                                from -1 to 1 ,@result))
            else do (setf result
                          `(loop for ,(aref indices (1- (- dim d)))
                              from -1 to 1 append ,result))
            finally (return result))))

     (defparameter *relative-neighbours3* (relative-neighbours 3))
     (defparameter *relative-neighbours4* (relative-neighbours 4))

     (defun idx-adder (idx)
       "Return a function that adds IDX to its input."
       (lambda (x) (mapcar #'+ idx x)))

     (defun get-neighbours-of (idx)
       "Return a list of the neighbours of IDX."
       (cond ((= (length idx) 3) (mapcar (idx-adder idx) *relative-neighbours3*))
             ((= (length idx) 4) (mapcar (idx-adder idx) *relative-neighbours4*))
             (t (error "get-neighbours-of: idx should have length 3 or 4; 
     other dimensions not implemented."))))

     (defun uninitialized-neighbours-of (idx)
       "Return a list of the uninitialized neighbours "
       (remove-if-not #'uninitialized-p (get-neighbours-of idx)))

     (defun count-active-neighbours (idx)
       "Return a count of neighbours with state 1."
       (count-if #'active-p (get-neighbours-of idx)))

     (defun activation (idx)
       "Compute activation for cube at IDX."
       (when (uninitialized-p idx)
         (initialize-state idx))
       (let ((num-active-neighbours (count-active-neighbours idx)))
         (cond ((and (= (get-state idx) 1) (<= 2 num-active-neighbours 3)) 1)
               ((and (= (get-state idx) 0) (= num-active-neighbours 3)) 1)
               (t 0))))

     (defmacro initialize-frontier (&optional (dim 3))
       "Initialize the *STATE* elements along the boundary of the slice."
       (let* ((vars (gensym-vector dim))
              (bounds (gensym-vector dim))
              (result `(loop for ,(aref vars 0)
                          from (1- (car ,(aref bounds 0)))
                          to (1+ (cdr ,(aref bounds 0)))
                          do (loop for ,(aref vars 1)
                                from (1- (car ,(aref bounds 1)))
                                to (1+ (cdr ,(aref bounds 1)))
                                do (activation (list ,@(map 'list #'identity vars)))))))
         `(multiple-value-bind ,(map 'list 'identity bounds) (get-state-bounds *state* ,dim)
            ,(loop for d from 2 below dim
                do (setf result `(loop for ,(aref vars d)
                                    from (1- (car ,(aref bounds d)))
                                    to (1+ (cdr ,(aref bounds d)))
                                    do ,result))
                  finally (return result)))))

     (defun update-state ()
       "Update *STATE* with the next cycle's configuration."
       (multiple-value-bind (new-state uninit)
           (loop for idx being the hash-keys of *state*
              collect (cons idx (activation idx)) into new-state
              append (uninitialized-neighbours-of idx) into uninit
              finally (return (values new-state (remove-duplicates uninit :test 'equalp))))
         (loop for idx in uninit
            do (setf (gethash idx *state*) (activation idx)))
         (loop for item in new-state
            for idx = (car item)
            for state = (cdr item)
            do (setf (gethash idx *state*) state))))

     (defun count-active-cubes ()
       "Count the number of active cubes in *STATE*."
       (loop for idx being the hash-keys of *state*
          using (hash-value state)
          counting (= state 1)))

     (defun day17-part1 ()
       (initialize)
       (initialize-frontier)
       (loop repeat 6 do (update-state))
       (count-active-cubes))

     (defun day17-part2 ()
       (initialize 4)
       (initialize-frontier 4)
       (loop repeat 6 do (update-state))
       (count-active-cubes))

     (verbose1
       (day17-part1)
       (day17-part2))
   #+end_src

   #+RESULTS:
   : (DAY17-PART1) : -> 353
   : (DAY17-PART2) : -> 2472
   


** Day 18
   :PROPERTIES:
   :ID:       3E812F30-024A-4A5B-AB3D-DD0230E93E25
   :END:

   #+begin_src lisp :exports both :results output :tangle day18.lisp
     (defparameter *day18* (read-file "d18.txt"))

     (defun parse-line (line)
       (let* ((characters
               (loop for c across line
                  if (and (char/= c #\Space) (digit-char-p c))
                  collect (parse-integer (string c))
                  else if (char/= c #\Space)
                  collect c)))
         characters))


     (defun plus-p (c)
       (and (characterp c) (char= #\+ c)))

     (defun times-p (c)
       (and (characterp c) (char= #\* c)))

     (defun operator-p (x)
       (and (characterp x) (or (char= #\+ x) (char= #\* x))))

     (defun paren-p (x)
       (and (characterp x) (or (char= #\( x) (char= #\) x))))

     (defun open-paren-p (x)
       (and (characterp x) (char= #\( x)))

     (defun close-paren-p (x)
       (and (characterp x) (char= #\) x)))

     (defun get-operator (c)
       (when (operator-p c)
         (cond ((plus-p c) #'+)
               ((times-p c) #'*)
               (t nil))))

     (defun compute-line (expr)
       "Compute EXPR with first-come-first-served operator precedence."
       (loop for tail on expr for x in expr
          with paren-level = 0
          with digit-stack = nil
          with oper-stack = nil
          while (>= paren-level 0)
          ;; If #\(, compute the inner expression and add it to the digit-stack
          if (and (zerop paren-level) (open-paren-p x))
          do (progn
               (push (compute-line (cdr tail)) digit-stack)
               (incf paren-level))
          ;; Ignore nested #\(
          else if (open-paren-p x)
          do (incf paren-level)
          ;; Detect unnesting
          else if (close-paren-p x)
          do (decf paren-level)
          ;; Add numbers to the digit stack
          else if (and (zerop paren-level) (numberp x))
          do (push x digit-stack)
          ;; Add operators to the operator stack
          else if (and (zerop paren-level) (operator-p x))
          do (push x oper-stack)
          ;; Compute when possible - first come first served!
          if (and (= 2 (length digit-stack)) oper-stack)
          do (progn
               (let* ((a (pop digit-stack))
                      (b (pop digit-stack))
                      (oper-char (pop oper-stack))
                      (result (funcall (get-operator oper-char) a b)))
                 (push result digit-stack)))
          ;; the final item on the digit stack is the final answer
          finally (return (pop digit-stack))))

     (defun compute-line2 (expr)
       "Compute EXPR with addition-first operator precedence."
       (loop for tail on expr for x in expr
          with paren-level = 0
          with digit-stack = nil
          with oper-stack = nil
          while (>= paren-level 0)
          ;; If #\(, compute the inner expression and add it to the digit-stack
          if (and (zerop paren-level) (open-paren-p x))
          do (progn
               (push (compute-line2 (cdr tail)) digit-stack)
               (incf paren-level))
          ;; Ignore nested #\(
          else if (open-paren-p x)
          do (incf paren-level)
          ;; Detect unnesting
          else if (close-paren-p x)
          do (decf paren-level)
          ;; Add numbers to the digit stack
          else if (and (zerop paren-level) (numberp x))
          do (push x digit-stack)
          ;; Add operators to the operator stack
          else if (and (zerop paren-level) (operator-p x))
          do (push x oper-stack)
          ;; If we just added a number to the digit-stack and there's a + on the
          ;; oper-stack, then we're all set for adding.
          if (and (or (numberp x) (close-paren-p x))
                  (>= (length digit-stack) 2)
                  (plus-p (car oper-stack)))
          do (let* ((a (pop digit-stack))
                    (b (pop digit-stack)))
               (pop oper-stack) ;; remove the #\+
               (push (funcall #'+ a b) digit-stack))
          ;; We did all the additions, so only multiplications remain;
          ;; return the product of the digit-stack.
          finally (return (apply #'* digit-stack))))

     (defun report-result (val string ans)
       (let ((result (= val ans)))
         (format t "~:[FAIL~;pass~]: ~a -> ~a ~:[/=~;==~] ~a~%" result string val result ans)
         result))

     (defmacro check-func (func &body string-ans-pairs)
       `(progn ,@(loop for (string ans) on string-ans-pairs
                    if (and (stringp string))
                    collect `(report-result
                              (funcall ,func (parse-line ,string))
                              ,string ,ans))))

     (check-func #'compute-line
       "2 * 3 + (4 * 5)" 26
       "5 + (8 * 3 + 9 + 3 * 4 * 3)" 437
       "5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4))" 12240
       "((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2" 13632)

     (check-func #'compute-line2
       "1 + (2 * 3) + (4 * (5 + 6))" 51
       "2 * 3 + (4 * 5)" 46
       "5 + (8 * 3 + 9 + 3 * 4 * 3)" 1445
       "5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4))" 669060
       "((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2" 23340)

     (defun main (&optional (func #'compute-line))
       (apply #'+ (loop for line in *day18* collect (funcall func (parse-line line)))))

     (defun day18-part1 ()
       (main))

     (defun day18-part2 ()
       (main #'compute-line2))

     (verbose1
       (day18-part1)
       (day18-part2))
   #+end_src

   #+RESULTS:
   #+begin_example
   pass: 2 * 3 + (4 * 5) -> 26 == 26
   pass: 5 + (8 * 3 + 9 + 3 * 4 * 3) -> 437 == 437
   pass: 5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4)) -> 12240 == 12240
   pass: ((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2 -> 13632 == 13632
   pass: 1 + (2 * 3) + (4 * (5 + 6)) -> 51 == 51
   pass: 2 * 3 + (4 * 5) -> 46 == 46
   pass: 5 + (8 * 3 + 9 + 3 * 4 * 3) -> 1445 == 1445
   pass: 5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4)) -> 669060 == 669060
   pass: ((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2 -> 23340 == 23340
   (DAY18-PART1) : -> 280014646144
   (DAY18-PART2) : -> 9966990988262
   #+end_example
   
One attempt each.

** Day 19

   #+begin_src lisp :exports both :results output :tangle day19.lisp
     (ql:quickload 'split-sequence :silent t)

     (defparameter *day19* (read-file "d19.txt"))

     (defun zero-length-p (sequence)
       (zerop (length sequence)))

     (defun str-base-rule-p (rule-text)
       (some #'(lambda (x) (find x rule-text)) (list #\a #\b)))

     (defun base-rule-p (rule)
       (when (and (characterp (cdr rule))
                  (or (char= (cdr rule) #\a)
                      (char= (cdr rule) #\b)))
         (cdr rule)))

     (defun str-disjunction-p (rule-text)
       (find #\| rule-text))

     (defun parse-input ()
       (labels ((load-data ()
                  (destructuring-bind (rules messages)
                      (split-sequence:split-sequence-if
                       #'zero-length-p
                       (read-file "d19.txt"))
                    (values rules messages)))
                (parse-rule-text (rule-text)
                  (cond ((str-base-rule-p rule-text) (str-base-rule-p rule-text))
                        ((str-disjunction-p rule-text)
                         (mapcar #'(lambda (x) (if (string= x "|") #\| (parse-integer x)))
                                 (remove-if
                                  #'zero-length-p
                                  (split-sequence:split-sequence-if
                                   #'(lambda (x) (char= x #\Space))
                                   rule-text))))
                        (t (mapcar #'parse-integer
                                   (split-sequence:split-sequence #\Space rule-text)))))
                (parse-rule (rule-line)
                  (destructuring-bind (rule-name rule-text)
                      (split-sequence:split-sequence #\: rule-line)
                    (cons (parse-integer rule-name) (parse-rule-text (subseq rule-text 1))))))
         (multiple-value-bind (rules messages) (load-data)
           (values (mapcar #'parse-rule rules) messages))))

     (multiple-value-bind (rules messages) (parse-input)
       (defparameter *rules* rules)
       (defparameter *messages* messages))

     ,*rules*

     (defun first-two (list)
       (when (listp list)
         (list (car list) (cadr list))))

     (defun last-two (list)
       (when (listp list)
         (let ((rev (reverse list)))
           (list (cadr rev) (car rev)))))

     (defun build-tree (rule-number)
       (let* ((rule (assoc rule-number *rules*))
              (rule-body (cdr rule)))
         (cond ((base-rule-p rule) (base-rule-p rule))
               (t
                (loop for number in rule-body
                   if (numberp number)
                   collect (build-tree number)
                   else collect #\|)))))

     (build-tree 0)

     ;;;; tree snippet
     ;; (#\b
     ;;      (#\a (((#\a #\| #\b) (#\a #\| #\b)) #\a #\| (#\b #\b #\| #\a #\a) #\b)
     ;;       #\| #\b (#\a (#\b #\a) #\| #\b (#\b #\b)))
     ;;      #\| #\a
     ;;      (#\a
     ;;       ((#\a #\a #\| #\b (#\a #\| #\b)) #\b #\|
     ;;        ((#\a #\| #\b) #\b #\| #\a #\a) #\a)
     ;;       #\| #\b
     ;;       (((#\a #\| #\b) (#\a #\| #\b)) #\a #\| (#\b #\b #\| #\a #\a) #\b)))

     ;; 0: 4 1 5
     ;; 1: 2 3 | 3 2
     ;; 2: 4 4 | 5 5
     ;; 3: 4 5 | 5 4
     ;; 4: "a"
     ;; 5: "b"
     ;; 
     ;;                     0
     ;;     4               1               5
     ;;     a     2     3   |   3     2     b
     ;;         44|55 45|54   45|54 44|55
     ;;         aa|bb ab|ba   ab|ba aa|bb
     ;; ababbb
     ;; bababa
     ;; abbbab
     ;; aaabbb
     ;; aaaabbb



     (defun day19-part1 ()
       nil)

     (defun day19-part2 ()
       nil)

     (verbose1
       (day19-part1)
       (day19-part2))
   #+end_src
   

** Day 20

   #+begin_src lisp :exports both :results output :tangle day20.lisp
     (ql:quickload 'split-sequence :silent t)

     (defun parse-input ()
       (labels ((load-data () (read-file "d20.txt"))
                (split-tiles ()
                  (split-sequence:split-sequence-if
                   #'(lambda (line)
                       (zerop (length line)))
                   (load-data)))
                (parse-tile-name (line)
                  (parse-integer (remove-if-not #'digit-char-p line)))
                (create-tile-array (lines)
                  (make-array '(10 10) :initial-contents lines))
                (parse-tile (lines)
                  (values (parse-tile-name (car lines))
                          (create-tile-array (cdr lines))))
                (hash-tile (tbl tile-lines)
                  (when tile-lines
                    (multiple-value-bind (tile-name tile-arr) (parse-tile tile-lines) 
                      (setf (gethash tile-name tbl) tile-arr)
                      tile-name)))
                (main ()
                  (loop for tile-lines in (split-tiles)
                     with tbl = (make-hash-table)
                     with keys = nil
                     if tile-lines
                     do (push (hash-tile tbl tile-lines) keys)
                     finally (return (values tbl keys)))))
         (main)))

     (multiple-value-bind (tbl tile-keys) (parse-input)
       (defparameter *tbl* tbl)
       (defparameter *tile-keys* tile-keys))

     (defun count-hashes-nesw (tile-name)
       (let ((tile (gethash tile-name *tbl*))
             (east-west (loop for i from 0 to 9
                           counting (char= (aref tile i 0) #\#) into west
                           counting (char= (aref tile i 9) #\#) into east
                           finally (return (cons east west))))
             (north-south (loop for j from 0 to 9
                             counting (char= (aref tile 0 j) #\#) into north
                             counting (char= (aref tile 9 j) #\#) into south
                             finally (return (cons north south)))))
         (list (car north-south) (car east-west)
               (cdr north-south) (cdr east-west))))

     (defun edges-match-p (edge1 edge2)
       (loop for c1 in edge1
          for c2 in edge2
          if (char/= c1 c2)
          do (return-from edges-match-p nil)
          finally (return t)))

     (defun get-edge (tile-name side &optional (rev nil))
       (labels ((get-ns-edge (tile &optional (north t))
                  (loop for j from 0 to 9
                     with i = (or (and north 0) (and (not north) 9))
                     collect (aref tile i j)))
                (get-ew-edge (tile &optional (east t))
                  (loop for i from 0 to 9
                     with j = (or (and east 9) (and (not east) 0))
                     collect (aref tile i j)))
                (get-edge-from (tile)
                  (cond ((eq side :n) (get-ns-edge tile))
                        ((eq side :e) (get-ew-edge tile))
                        ((eq side :s) (get-ns-edge tile nil))
                        ((eq side :w) (get-ew-edge tile nil))))
                (reverse-maybe (edge) (if rev (reverse edge) edge)))
         (reverse-maybe (get-edge-from (gethash tile-name *tbl*)))))

     ;;;; If you're an edge tile you only match with two other tiles. Moreover, you
     ;;;; should only be able to match on one side if the problem is set up in the
     ;;;; easiest way. Let's proceed and hope for the best.




     (defun test-tile-fit (tile-name1 tile-name2)
       (let ((directions (list :n :e :s :w)))
         (loop for d1 in directions
            for edge1 = (get-edge tile-name1 d1)
            do (loop for d2 in directions
                  for edge2 = (get-edge tile-name2 d2)
                  if (edges-match-p edge1 edge2)
                  do (return-from test-tile-fit (list d1 d2 nil))
                  if (edges-match-p (reverse edge1) edge2)
                  do (return-from test-tile-fit (list d1 d2 :rev))))))

     (defun brute-tile-fits ()
       (loop for key1 in *tile-keys*
        for key-tail on *tile-keys*
        append (loop for key2 in (cdr key-tail)
                  for result = (test-tile-fit key1 key2)
                  if result 
                  collect (list (cons key1 key2) result))))

     (defun in-cons-cell (tile-name)
       #'(lambda (x) (or (= (caar x) tile-name)
                         (= (cdar x) tile-name))))

     (defun get-matches-for (tile-name tile-matches)
       (remove-if-not (in-cons-cell tile-name) tile-matches))

     (defun find-corners (tile-matches)
       (loop for tile-name in *tile-keys*
          if (= (length (get-matches-for tile-name tile-matches)) 2)
          collect tile-name))

     (defparameter *arrangement* (make-array '(12 12)))



     (defun dotted-pair-p (item)
       (and (listp item) (not (listp (cdr item)))))

     (defun cons-pair (dotted-pair tile-name)
       (when (and (dotted-pair-p dotted-pair) (numberp tile-name))
         (cond ((= (car dotted-pair) tile-name) (cdr dotted-pair))
               ((= (cdr dotted-pair) tile-name) (car dotted-pair))
               (t nil))))

     (defun get-tile-names-matching (tile-name tile-matches)
       (let* ((match-pairs
               (mapcar #'car (get-matches-for tile-name tile-matches))))
         (mapcar #'(lambda (dotted-pair) (cons-pair dotted-pair tile-name)) match-pairs)))

     (defun find-mutual-matches (tile-name1 tile-name2 tile-matches)
       (let ((matches1 (get-tile-names-matching tile-name1 tile-matches))
             (matches2 (get-tile-names-matching tile-name2 tile-matches)))
         (intersection matches1 matches2)))

     (defun assigned-tiles ()
       (loop for i from 0 below 12
          append (loop for j from 0 below 12
                    for tn = (aref *arrangement* i j)
                    if (/= tn 0)
                    collect tn)))

     (defun unassigned-mutual-matches (tn1 tn2 tile-matches)
       (let* ((mutual-matches (find-mutual-matches tn1 tn2 tile-matches))
              (already-seen (assigned-tiles)))
         (set-difference mutual-matches already-seen)))

     (defun unassigned-matches (tile-name tile-matches)
       (let* ((matches (get-tile-names-matching tile-name tile-matches))
              (already-seen (assigned-tiles)))
         (set-difference matches already-seen)))

     (defun arrange-tiles ()
       (let* ((tile-matches (brute-tile-fits))
              (corners (find-corners tile-matches))
              (first-corner (car corners))
              (matches-first-corner (get-tile-names-matching first-corner tile-matches)))
         ;; initialize
         (setf (aref *arrangement* 0 0) first-corner)
         (setf (aref *arrangement* 0 1) (car matches-first-corner))
         (setf (aref *arrangement* 1 0) (cadr matches-first-corner))

         ;; begin fill
         ;; (testing...)
         (unassigned-mutual-matches  (car matches-first-corner) (cadr matches-first-corner) tile-matches)
         (unassigned-matches (car matches-first-corner) tile-matches)))

     ;; test:
     (arrange-tiles)


     (defun day20-part1 ()
       (let ((tile-matches (brute-tile-fits)))
         (apply #'* (find-corners tile-matches))))

     (defun day20-part2 ()
       nil)

     (verbose1
       (day20-part1)
       (day20-part2))
   #+end_src
   





** Day xx
   :PROPERTIES:
   :ID:       FF9FD49E-3606-4443-A020-4E2454F05DA5
   :END:

   This is a skeleton for easily creating the next day.

   #+begin_src lisp :exports both :results output :tangle dayxx.lisp
     (load "my-utils.lisp")


     (defun dayxx-part1 ()
       nil)

     (defun dayxx-part2 ()
       nil)

     (verbose1
       (dayxx-part1)
       (dayxx-part2))
   #+end_src
   


